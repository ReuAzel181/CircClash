"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/quickplay/page",{

/***/ "(app-pages-browser)/./lib/physics.ts":
/*!************************!*\
  !*** ./lib/physics.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector: function() { return /* binding */ Vector; },\n/* harmony export */   addForce: function() { return /* binding */ addForce; },\n/* harmony export */   applyChainKnockback: function() { return /* binding */ applyChainKnockback; },\n/* harmony export */   applyFriction: function() { return /* binding */ applyFriction; },\n/* harmony export */   createCircleEntity: function() { return /* binding */ createCircleEntity; },\n/* harmony export */   createPhysicsWorld: function() { return /* binding */ createPhysicsWorld; },\n/* harmony export */   createProjectile: function() { return /* binding */ createProjectile; },\n/* harmony export */   detectCollision: function() { return /* binding */ detectCollision; },\n/* harmony export */   fireWeapon: function() { return /* binding */ fireWeapon; },\n/* harmony export */   handleBoundaryCollision: function() { return /* binding */ handleBoundaryCollision; },\n/* harmony export */   integrate: function() { return /* binding */ integrate; },\n/* harmony export */   regenerateEnergy: function() { return /* binding */ regenerateEnergy; },\n/* harmony export */   resolveCollision: function() { return /* binding */ resolveCollision; },\n/* harmony export */   setVelocity: function() { return /* binding */ setVelocity; },\n/* harmony export */   simulateStep: function() { return /* binding */ simulateStep; },\n/* harmony export */   teleport: function() { return /* binding */ teleport; },\n/* harmony export */   updateAI: function() { return /* binding */ updateAI; },\n/* harmony export */   updateWeaponCooldowns: function() { return /* binding */ updateWeaponCooldowns; }\n/* harmony export */ });\n// Core physics types and functions for deterministic circle-based gameplay\n// Vector math utilities\nconst Vector = {\n    create: function() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        return {\n            x,\n            y\n        };\n    },\n    add: (a, b)=>({\n            x: a.x + b.x,\n            y: a.y + b.y\n        }),\n    subtract: (a, b)=>({\n            x: a.x - b.x,\n            y: a.y - b.y\n        }),\n    multiply: (v, scalar)=>({\n            x: v.x * scalar,\n            y: v.y * scalar\n        }),\n    dot: (a, b)=>a.x * b.x + a.y * b.y,\n    magnitude: (v)=>Math.sqrt(v.x * v.x + v.y * v.y),\n    normalize: (v)=>{\n        const mag = Vector.magnitude(v);\n        if (mag === 0) return Vector.create();\n        return Vector.multiply(v, 1 / mag);\n    },\n    distance: (a, b)=>{\n        const diff = Vector.subtract(a, b);\n        return Vector.magnitude(diff);\n    },\n    lerp: (a, b, t)=>({\n            x: a.x + (b.x - a.x) * t,\n            y: a.y + (b.y - a.y) * t\n        }),\n    rotate: (v, angle)=>{\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        return {\n            x: v.x * cos - v.y * sin,\n            y: v.x * sin + v.y * cos\n        };\n    }\n};\n// Physics simulation functions\nfunction createPhysicsWorld(width, height) {\n    return {\n        entities: new Map(),\n        gravity: Vector.create(0, 0),\n        airFriction: 0.99,\n        timeAccumulator: 0,\n        fixedTimeStep: 1 / 60,\n        bounds: {\n            width,\n            height\n        }\n    };\n}\nfunction createCircleEntity(id, x, y, radius) {\n    let type = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"player\";\n    return {\n        id,\n        position: Vector.create(x, y),\n        velocity: Vector.create(),\n        acceleration: Vector.create(),\n        radius,\n        mass: Math.PI * radius * radius,\n        health: 100,\n        maxHealth: 100,\n        damage: 20,\n        restitution: 0.95,\n        friction: 0.98,\n        isStatic: false,\n        type,\n        invulnerableUntil: 0\n    };\n}\nfunction createProjectile(id, x, y, direction, speed, ownerId) {\n    let lifetime = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 3000;\n    const velocity = Vector.multiply(Vector.normalize(direction), speed);\n    return {\n        id,\n        position: Vector.create(x, y),\n        velocity,\n        acceleration: Vector.create(),\n        radius: 5,\n        mass: 1,\n        health: 1,\n        maxHealth: 1,\n        damage: 10,\n        restitution: 0.2,\n        friction: 1,\n        isStatic: false,\n        type: \"projectile\",\n        ownerId,\n        speed,\n        lifetime,\n        piercing: 0,\n        hitsRemaining: 1\n    };\n}\n// Collision detection\nfunction detectCollision(a, b) {\n    const distance = Vector.distance(a.position, b.position);\n    const minDistance = a.radius + b.radius;\n    if (distance >= minDistance) {\n        return null // No collision\n        ;\n    }\n    const normal = Vector.normalize(Vector.subtract(b.position, a.position));\n    const penetration = minDistance - distance;\n    const relativeVelocity = Vector.magnitude(Vector.subtract(a.velocity, b.velocity));\n    return {\n        entityA: a,\n        entityB: b,\n        normal,\n        penetration,\n        relativeVelocity\n    };\n}\n// Collision response with momentum-based damage\nfunction resolveCollision(collision, world) {\n    const { entityA, entityB, normal, penetration, relativeVelocity } = collision;\n    // Skip if either entity is static and the other is a projectile\n    if ((entityA.isStatic || entityB.isStatic) && (entityA.type === \"projectile\" || entityB.type === \"projectile\")) {\n        return;\n    }\n    // Positional correction to prevent overlap\n    const correctionPercent = 0.8;\n    const correction = Vector.multiply(normal, penetration * correctionPercent);\n    if (!entityA.isStatic && !entityB.isStatic) {\n        const totalMass = entityA.mass + entityB.mass;\n        entityA.position = Vector.subtract(entityA.position, Vector.multiply(correction, entityB.mass / totalMass));\n        entityB.position = Vector.add(entityB.position, Vector.multiply(correction, entityA.mass / totalMass));\n    } else if (!entityA.isStatic) {\n        entityA.position = Vector.subtract(entityA.position, correction);\n    } else if (!entityB.isStatic) {\n        entityB.position = Vector.add(entityB.position, correction);\n    }\n    // Calculate momentum-based damage (reduced for longer battles)\n    const baseDamage = Math.max(entityA.damage, entityB.damage);\n    const momentumDamage = baseDamage * 0.3 * (1 + Math.min(relativeVelocity / 600, 1) // Reduced by 70%\n    );\n    // Apply damage with invulnerability frames\n    const currentTime = Date.now();\n    if (entityA.type !== \"projectile\" && entityB.type !== \"pickup\" && entityA.invulnerableUntil < currentTime) {\n        entityA.health = Math.max(0, entityA.health - momentumDamage);\n        entityA.invulnerableUntil = currentTime + 500 // 500ms immunity\n        ;\n    }\n    if (entityB.type !== \"projectile\" && entityA.type !== \"pickup\" && entityB.invulnerableUntil < currentTime) {\n        entityB.health = Math.max(0, entityB.health - momentumDamage);\n        entityB.invulnerableUntil = currentTime + 500;\n    }\n    // Elastic collision response\n    if (!entityA.isStatic && !entityB.isStatic) {\n        const relativeVel = Vector.subtract(entityA.velocity, entityB.velocity);\n        const velAlongNormal = Vector.dot(relativeVel, normal);\n        if (velAlongNormal > 0) return; // Objects separating\n        const restitution = Math.max(entityA.restitution, entityB.restitution) * 0.9 // Realistic bouncing\n        ;\n        const impulseScalar = -(1 + restitution) * velAlongNormal / (1 / entityA.mass + 1 / entityB.mass);\n        const impulse = Vector.multiply(normal, impulseScalar);\n        // Small random variation for natural movement\n        const randomBoost = Vector.create((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);\n        entityA.velocity = Vector.add(entityA.velocity, Vector.add(Vector.multiply(impulse, 1 / entityA.mass), randomBoost));\n        entityB.velocity = Vector.subtract(entityB.velocity, Vector.add(Vector.multiply(impulse, 1 / entityB.mass), randomBoost));\n    }\n    // Handle projectile hits\n    if (entityA.type === \"projectile\" || entityB.type === \"projectile\") {\n        const projectile = entityA.type === \"projectile\" ? entityA : entityB;\n        const target = entityA.type === \"projectile\" ? entityB : entityA;\n        // Prevent friendly fire - projectiles don't hurt their owner\n        if (projectile.ownerId === target.id) {\n            return; // Skip damage if projectile hits its owner\n        }\n        // Apply damage to target\n        if (target.type === \"player\" && target.health > 0) {\n            const projectileDamage = projectile.damage || 10 // Reduced default from 25 to 10\n            ;\n            target.health = Math.max(0, target.health - projectileDamage);\n            // Check for critical hit (high velocity impact)\n            const isCriticalHit = relativeVelocity > 400;\n            if (isCriticalHit && target.weaponId && target.type === \"player\") {\n                // Weapon swap on critical hit - drop weapon as pickup\n                spawnWeaponPickup(world, target.position, target.weaponId);\n                target.weaponId = undefined;\n            }\n        }\n        // Remove projectile or reduce piercing\n        if (projectile.hitsRemaining <= 1) {\n            world.entities.delete(projectile.id);\n        } else {\n            projectile.hitsRemaining--;\n        }\n    }\n}\n// Chain knockback - when moving circle forces another into a third\nfunction applyChainKnockback(world, collision) {\n    const { entityA, entityB } = collision;\n    const pushingEntity = Vector.magnitude(entityA.velocity) > Vector.magnitude(entityB.velocity) ? entityA : entityB;\n    const pushedEntity = pushingEntity === entityA ? entityB : entityA;\n    // Find entities that might be hit by the pushed entity\n    const chainRadius = pushedEntity.radius + 50 // Detection range\n    ;\n    for (const [id, entity] of world.entities){\n        if (entity.id === pushedEntity.id || entity.id === pushingEntity.id) continue;\n        const distance = Vector.distance(pushedEntity.position, entity.position);\n        if (distance <= chainRadius) {\n            // Apply reduced knockback\n            const knockbackDirection = Vector.normalize(Vector.subtract(entity.position, pushedEntity.position));\n            const knockbackForce = Vector.magnitude(pushedEntity.velocity) * 0.3 // Reduced force\n            ;\n            if (!entity.isStatic) {\n                entity.velocity = Vector.add(entity.velocity, Vector.multiply(knockbackDirection, knockbackForce));\n            }\n        }\n    }\n}\nfunction spawnWeaponPickup(world, position, weaponId) {\n    const pickup = createCircleEntity(\"pickup_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)), position.x, position.y, 15, \"pickup\");\n    pickup.weaponId = weaponId;\n    pickup.isStatic = true;\n    pickup.lifetime = 15000 // 15 seconds\n    ;\n    world.entities.set(pickup.id, pickup);\n}\n// Apply friction to all entities\nfunction applyFriction(world) {\n    for (const [id, entity] of world.entities){\n        if (!entity.isStatic && entity.type !== \"projectile\") {\n            entity.velocity = Vector.multiply(entity.velocity, entity.friction);\n            // Stop very slow movement to prevent jitter\n            if (Vector.magnitude(entity.velocity) < 0.1) {\n                entity.velocity = Vector.create();\n            }\n        }\n    }\n}\n// Integrate position and velocity using Verlet integration\nfunction integrate(entity, dt) {\n    if (entity.isStatic) return;\n    // Apply gravity\n    entity.velocity = Vector.add(entity.velocity, Vector.multiply(entity.acceleration, dt));\n    // Update position\n    entity.position = Vector.add(entity.position, Vector.multiply(entity.velocity, dt));\n    // Reset acceleration for next frame\n    entity.acceleration = Vector.create();\n}\n// Boundary collision\nfunction handleBoundaryCollision(entity, bounds) {\n    if (entity.isStatic) return;\n    // Projectiles should disappear when hitting walls (more realistic)\n    if (entity.type === \"projectile\") {\n        if (entity.position.x - entity.radius <= 0 || entity.position.x + entity.radius >= bounds.width || entity.position.y - entity.radius <= 0 || entity.position.y + entity.radius >= bounds.height) {\n            // Mark for removal by setting health to 0\n            entity.health = 0;\n            return;\n        }\n    }\n    const bounceFactor = entity.restitution * 0.95 // Slight energy loss for realistic bouncing\n    ;\n    // Left boundary\n    if (entity.position.x - entity.radius < 0) {\n        entity.position.x = entity.radius;\n        entity.velocity.x = -entity.velocity.x * bounceFactor;\n        // Small random component for variety\n        entity.velocity.y += (Math.random() - 0.5) * 20;\n    }\n    // Right boundary\n    if (entity.position.x + entity.radius > bounds.width) {\n        entity.position.x = bounds.width - entity.radius;\n        entity.velocity.x = -entity.velocity.x * bounceFactor;\n        // Small random component for variety\n        entity.velocity.y += (Math.random() - 0.5) * 20;\n    }\n    // Top boundary\n    if (entity.position.y - entity.radius < 0) {\n        entity.position.y = entity.radius;\n        entity.velocity.y = -entity.velocity.y * bounceFactor;\n        // Small random component for variety\n        entity.velocity.x += (Math.random() - 0.5) * 20;\n    }\n    // Bottom boundary\n    if (entity.position.y + entity.radius > bounds.height) {\n        entity.position.y = bounds.height - entity.radius;\n        entity.velocity.y = -entity.velocity.y * bounceFactor;\n        // Small random component for variety\n        entity.velocity.x += (Math.random() - 0.5) * 20;\n    }\n}\n// Main physics simulation step\nfunction simulateStep(world, deltaTime) {\n    world.timeAccumulator += deltaTime;\n    // Fixed timestep with accumulator pattern for determinism\n    while(world.timeAccumulator >= world.fixedTimeStep){\n        const currentTime = Date.now();\n        // Remove expired entities\n        for (const [id, entity] of world.entities){\n            if (entity.lifetime && currentTime > (entity.lifetime + entity.spawnTime || 0)) {\n                world.entities.delete(id);\n                continue;\n            }\n            // Remove dead entities\n            if (entity.health <= 0) {\n                world.entities.delete(id);\n                continue;\n            }\n        }\n        // Update weapon systems and energy\n        for (const [id, entity] of world.entities){\n            updateWeaponCooldowns(entity, currentTime);\n            regenerateEnergy(entity, world.fixedTimeStep);\n        }\n        // Update AI (will be called with weapons from outside)\n        if (world.weapons) {\n            for (const [id, entity] of world.entities){\n                if (entity.health > 0) {\n                    updateAI(entity, world, world.fixedTimeStep, world.weapons);\n                }\n            }\n        }\n        // Integration step - handle projectiles separately\n        for (const [id, entity] of world.entities){\n            if (entity.type === \"projectile\") {\n                // Projectiles only update position, no physics interactions\n                entity.position.x += entity.velocity.x * world.fixedTimeStep;\n                entity.position.y += entity.velocity.y * world.fixedTimeStep;\n                // Check boundaries for projectiles (remove when hitting walls)\n                if (entity.position.x - entity.radius <= 0 || entity.position.x + entity.radius >= world.bounds.width || entity.position.y - entity.radius <= 0 || entity.position.y + entity.radius >= world.bounds.height) {\n                    entity.health = 0 // Mark for removal\n                    ;\n                }\n            } else {\n                // Normal physics for non-projectiles\n                integrate(entity, world.fixedTimeStep);\n                handleBoundaryCollision(entity, world.bounds);\n            }\n        }\n        // Collision detection and response\n        const entities = Array.from(world.entities.values());\n        for(let i = 0; i < entities.length; i++){\n            for(let j = i + 1; j < entities.length; j++){\n                const entityA = entities[i];\n                const entityB = entities[j];\n                // Skip projectile-to-projectile collisions\n                if (entityA.type === \"projectile\" && entityB.type === \"projectile\") {\n                    continue;\n                }\n                const collision = detectCollision(entityA, entityB);\n                if (collision) {\n                    resolveCollision(collision, world);\n                    // Only apply chain knockback for non-projectile entities\n                    if (entityA.type !== \"projectile\" && entityB.type !== \"projectile\") {\n                        applyChainKnockback(world, collision);\n                    }\n                }\n            }\n        }\n        // Apply friction\n        applyFriction(world);\n        world.timeAccumulator -= world.fixedTimeStep;\n    }\n}\n// Utility functions for external use\nfunction addForce(entity, force) {\n    if (!entity.isStatic) {\n        entity.acceleration = Vector.add(entity.acceleration, Vector.multiply(force, 1 / entity.mass));\n    }\n}\nfunction setVelocity(entity, velocity) {\n    if (!entity.isStatic) {\n        entity.velocity = velocity;\n    }\n}\nfunction teleport(entity, position) {\n    entity.position = position;\n}\n// Weapon system integration\nfunction fireWeapon(world, entityId, weaponData, targetDirection, currentTime) {\n    var _entity_weaponCooldowns;\n    const entity = world.entities.get(entityId);\n    if (!entity) return false;\n    // Check cooldown and energy\n    const cooldownEnd = ((_entity_weaponCooldowns = entity.weaponCooldowns) === null || _entity_weaponCooldowns === void 0 ? void 0 : _entity_weaponCooldowns.get(weaponData.id)) || 0;\n    if (currentTime < cooldownEnd) return false;\n    if ((entity.energy || 0) < weaponData.cost) return false;\n    // Update entity cooldown and energy\n    if (!entity.weaponCooldowns) entity.weaponCooldowns = new Map();\n    entity.weaponCooldowns.set(weaponData.id, currentTime + weaponData.cooldownMs);\n    entity.energy = (entity.energy || 0) - weaponData.cost;\n    // Create weapon effect\n    if (weaponData.type === \"projectile\") {\n        const projectile = createWeaponProjectile(entity, weaponData, targetDirection, currentTime);\n        world.entities.set(projectile.id, projectile);\n    } else if (weaponData.type === \"aura\") {\n        const aura = createWeaponAura(entity, weaponData, currentTime);\n        world.entities.set(aura.id, aura);\n    }\n    return true;\n}\nfunction createWeaponProjectile(owner, weaponData, direction, currentTime) {\n    const normalizedDir = Vector.normalize(direction);\n    const spawnOffset = Vector.multiply(normalizedDir, owner.radius + weaponData.radius + 2);\n    return {\n        id: \"projectile_\".concat(currentTime, \"_\").concat(Math.random()),\n        type: \"projectile\",\n        weaponId: weaponData.id,\n        ownerId: owner.id,\n        position: Vector.add(owner.position, spawnOffset),\n        velocity: Vector.multiply(normalizedDir, weaponData.projectileSpeed || 200),\n        acceleration: {\n            x: 0,\n            y: 0\n        },\n        radius: weaponData.radius,\n        mass: 1,\n        health: 1,\n        maxHealth: 1,\n        damage: weaponData.baseDamage,\n        restitution: 0.8,\n        friction: 0.02,\n        isStatic: false,\n        speed: weaponData.projectileSpeed || 200,\n        lifetime: weaponData.lifetime || 2000,\n        piercing: weaponData.piercing || 0,\n        hitsRemaining: weaponData.piercing || 0,\n        bounces: weaponData.bounces || 0,\n        bouncesRemaining: weaponData.bounces || 0,\n        special: weaponData.special || [],\n        spawnTime: currentTime\n    };\n}\nfunction createWeaponAura(owner, weaponData, currentTime) {\n    return {\n        id: \"aura_\".concat(currentTime, \"_\").concat(Math.random()),\n        type: \"aura\",\n        weaponId: weaponData.id,\n        ownerId: owner.id,\n        position: {\n            ...owner.position\n        },\n        velocity: {\n            x: 0,\n            y: 0\n        },\n        acceleration: {\n            x: 0,\n            y: 0\n        },\n        radius: weaponData.auraRadius || weaponData.radius,\n        mass: 0,\n        health: 1,\n        maxHealth: 1,\n        damage: weaponData.baseDamage,\n        restitution: 0,\n        friction: 0,\n        isStatic: true,\n        duration: weaponData.auraDuration || 1000,\n        special: weaponData.special || [],\n        affectedEntities: new Set(),\n        lifetime: weaponData.auraDuration || 1000,\n        spawnTime: currentTime\n    };\n}\nfunction updateWeaponCooldowns(entity, currentTime) {\n    if (!entity.weaponCooldowns) return;\n    for (const [weaponId, cooldownEnd] of entity.weaponCooldowns){\n        if (currentTime >= cooldownEnd) {\n            entity.weaponCooldowns.delete(weaponId);\n        }\n    }\n}\nfunction regenerateEnergy(entity, dt) {\n    if (entity.energy !== undefined && entity.maxEnergy !== undefined) {\n        entity.energy = Math.min(entity.maxEnergy, entity.energy + 20 * dt) // 20 energy/sec\n        ;\n    }\n}\n// AI Combat System\nfunction updateAI(entity, world, deltaTime, weapons) {\n    if (!entity.id.includes(\"ai\") && !entity.id.includes(\"bot\")) return;\n    const currentTime = Date.now();\n    // Find nearest enemy\n    let nearestEnemy = null;\n    let nearestDistance = Infinity;\n    for (const [id, otherEntity] of world.entities){\n        if (otherEntity === entity || otherEntity.health <= 0) continue;\n        if (entity.id.includes(\"bot\") && otherEntity.id.includes(\"bot\")) continue; // Bots don't fight each other\n        const distance = Vector.distance(entity.position, otherEntity.position);\n        if (distance < nearestDistance) {\n            nearestDistance = distance;\n            nearestEnemy = otherEntity;\n        }\n    }\n    if (!nearestEnemy) return;\n    // AI Behavior based on distance and health\n    const healthRatio = entity.health / entity.maxHealth;\n    const distanceToEnemy = nearestDistance;\n    // Movement AI\n    if (distanceToEnemy > 100) {\n        // Move towards enemy\n        const direction = Vector.normalize(Vector.subtract(nearestEnemy.position, entity.position));\n        const moveForce = Vector.multiply(direction, 200 * healthRatio) // Slower when hurt\n        ;\n        addForce(entity, moveForce);\n    } else if (distanceToEnemy < 50 && healthRatio < 0.3) {\n        // Retreat when low on health and too close\n        const direction = Vector.normalize(Vector.subtract(entity.position, nearestEnemy.position));\n        const retreatForce = Vector.multiply(direction, 300);\n        addForce(entity, retreatForce);\n    } else {\n        // Circle around enemy\n        const toEnemy = Vector.subtract(nearestEnemy.position, entity.position);\n        const perpendicular = {\n            x: -toEnemy.y,\n            y: toEnemy.x\n        };\n        const circleDirection = Vector.normalize(perpendicular);\n        const circleForce = Vector.multiply(circleDirection, 150);\n        addForce(entity, circleForce);\n    }\n    // Combat AI - try to attack every 1-2 seconds\n    if (!entity.lastAttackTime) entity.lastAttackTime = 0;\n    const timeSinceAttack = currentTime - entity.lastAttackTime;\n    const attackCooldown = 1000 + Math.random() * 1000 // 1-2 seconds\n    ;\n    if (timeSinceAttack > attackCooldown && distanceToEnemy < 200) {\n        // Find weapon to use\n        const availableWeapon = weapons.find((w)=>w.id === entity.weaponId);\n        if (availableWeapon && entity.energy && entity.energy >= availableWeapon.cost) {\n            const attackDirection = Vector.normalize(Vector.subtract(nearestEnemy.position, entity.position));\n            // Add some inaccuracy to make fights more interesting\n            const inaccuracy = (Math.random() - 0.5) * 0.3;\n            const finalDirection = {\n                x: attackDirection.x + inaccuracy,\n                y: attackDirection.y + inaccuracy\n            };\n            if (fireWeapon(world, entity.id, availableWeapon, Vector.normalize(finalDirection), currentTime)) {\n                entity.lastAttackTime = currentTime;\n            }\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ii8vIENvcmUgcGh5c2ljcyB0eXBlcyBhbmQgZnVuY3Rpb25zIGZvciBkZXRlcm1pbmlzdGljIGNpcmNsZS1iYXNlZCBnYW1lcGxheVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBWZWN0b3Ige1xyXG4gIHg6IG51bWJlclxyXG4gIHk6IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENpcmNsZUVudGl0eSB7XHJcbiAgaWQ6IHN0cmluZ1xyXG4gIHBvc2l0aW9uOiBWZWN0b3JcclxuICB2ZWxvY2l0eTogVmVjdG9yXHJcbiAgYWNjZWxlcmF0aW9uOiBWZWN0b3JcclxuICByYWRpdXM6IG51bWJlclxyXG4gIG1hc3M6IG51bWJlclxyXG4gIGhlYWx0aDogbnVtYmVyXHJcbiAgbWF4SGVhbHRoOiBudW1iZXJcclxuICBkYW1hZ2U6IG51bWJlclxyXG4gIHdlYXBvbklkPzogc3RyaW5nXHJcbiAgcmVzdGl0dXRpb246IG51bWJlciAvLyBCb3VuY2UgY29lZmZpY2llbnQgKDAtMSlcclxuICBmcmljdGlvbjogbnVtYmVyIC8vIE1vdmVtZW50IGZyaWN0aW9uICgwLTEpXHJcbiAgaXNTdGF0aWM6IGJvb2xlYW4gLy8gSW1tb3ZhYmxlIG9iamVjdHNcclxuICB0eXBlOiAncGxheWVyJyB8ICdwcm9qZWN0aWxlJyB8ICdwaWNrdXAnIHwgJ2hhemFyZCcgfCAnYXVyYSdcclxuICBvd25lcklkPzogc3RyaW5nIC8vIEZvciBwcm9qZWN0aWxlc1xyXG4gIGxpZmV0aW1lPzogbnVtYmVyIC8vIEZvciB0ZW1wb3JhcnkgZW50aXRpZXNcclxuICBpbnZ1bG5lcmFibGVVbnRpbD86IG51bWJlciAvLyBJbW11bml0eSBmcmFtZXNcclxuICAvLyBXZWFwb24gc3lzdGVtXHJcbiAgZXF1aXBwZWRXZWFwb24/OiBzdHJpbmdcclxuICB3ZWFwb25Db29sZG93bnM/OiBNYXA8c3RyaW5nLCBudW1iZXI+XHJcbiAgZW5lcmd5PzogbnVtYmVyXHJcbiAgbWF4RW5lcmd5PzogbnVtYmVyXHJcbiAgc3BlY2lhbD86IHN0cmluZ1tdIC8vIFNwZWNpYWwgYmVoYXZpb3IgZmxhZ3NcclxuICAvLyBBSSBzeXN0ZW1cclxuICBsYXN0QXR0YWNrVGltZT86IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFdlYXBvblByb2plY3RpbGUgZXh0ZW5kcyBDaXJjbGVFbnRpdHkge1xyXG4gIHR5cGU6ICdwcm9qZWN0aWxlJ1xyXG4gIHdlYXBvbklkOiBzdHJpbmdcclxuICBzcGVlZDogbnVtYmVyXHJcbiAgbGlmZXRpbWU6IG51bWJlclxyXG4gIHBpZXJjaW5nOiBudW1iZXIgLy8gSG93IG1hbnkgZW50aXRpZXMgaXQgY2FuIGhpdFxyXG4gIGhpdHNSZW1haW5pbmc6IG51bWJlclxyXG4gIGJvdW5jZXM6IG51bWJlclxyXG4gIGJvdW5jZXNSZW1haW5pbmc6IG51bWJlclxyXG4gIHNwZWNpYWw6IHN0cmluZ1tdXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2VhcG9uQXVyYSBleHRlbmRzIENpcmNsZUVudGl0eSB7XHJcbiAgdHlwZTogJ2F1cmEnXHJcbiAgd2VhcG9uSWQ6IHN0cmluZ1xyXG4gIGR1cmF0aW9uOiBudW1iZXJcclxuICBzcGVjaWFsOiBzdHJpbmdbXVxyXG4gIGFmZmVjdGVkRW50aXRpZXM6IFNldDxzdHJpbmc+IC8vIFRyYWNrIHdoaWNoIGVudGl0aWVzIGFyZSBpbiByYW5nZVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3RpbGUgZXh0ZW5kcyBDaXJjbGVFbnRpdHkge1xyXG4gIHR5cGU6ICdwcm9qZWN0aWxlJ1xyXG4gIHNwZWVkOiBudW1iZXJcclxuICBsaWZldGltZTogbnVtYmVyXHJcbiAgcGllcmNpbmc6IG51bWJlciAvLyBIb3cgbWFueSBlbnRpdGllcyBpdCBjYW4gaGl0XHJcbiAgaGl0c1JlbWFpbmluZzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGlzaW9uIHtcclxuICBlbnRpdHlBOiBDaXJjbGVFbnRpdHlcclxuICBlbnRpdHlCOiBDaXJjbGVFbnRpdHlcclxuICBub3JtYWw6IFZlY3RvclxyXG4gIHBlbmV0cmF0aW9uOiBudW1iZXJcclxuICByZWxhdGl2ZVZlbG9jaXR5OiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQaHlzaWNzV29ybGQge1xyXG4gIGVudGl0aWVzOiBNYXA8c3RyaW5nLCBDaXJjbGVFbnRpdHk+XHJcbiAgZ3Jhdml0eTogVmVjdG9yXHJcbiAgYWlyRnJpY3Rpb246IG51bWJlclxyXG4gIHRpbWVBY2N1bXVsYXRvcjogbnVtYmVyXHJcbiAgZml4ZWRUaW1lU3RlcDogbnVtYmVyIC8vIDEvNjAgZm9yIDYwZnBzIHBoeXNpY3NcclxuICBib3VuZHM6IHsgd2lkdGg6IG51bWJlcjsgaGVpZ2h0OiBudW1iZXIgfVxyXG59XHJcblxyXG4vLyBWZWN0b3IgbWF0aCB1dGlsaXRpZXNcclxuZXhwb3J0IGNvbnN0IFZlY3RvciA9IHtcclxuICBjcmVhdGU6ICh4OiBudW1iZXIgPSAwLCB5OiBudW1iZXIgPSAwKTogVmVjdG9yID0+ICh7IHgsIHkgfSksXHJcbiAgXHJcbiAgYWRkOiAoYTogVmVjdG9yLCBiOiBWZWN0b3IpOiBWZWN0b3IgPT4gKHtcclxuICAgIHg6IGEueCArIGIueCxcclxuICAgIHk6IGEueSArIGIueVxyXG4gIH0pLFxyXG4gIFxyXG4gIHN1YnRyYWN0OiAoYTogVmVjdG9yLCBiOiBWZWN0b3IpOiBWZWN0b3IgPT4gKHtcclxuICAgIHg6IGEueCAtIGIueCxcclxuICAgIHk6IGEueSAtIGIueVxyXG4gIH0pLFxyXG4gIFxyXG4gIG11bHRpcGx5OiAodjogVmVjdG9yLCBzY2FsYXI6IG51bWJlcik6IFZlY3RvciA9PiAoe1xyXG4gICAgeDogdi54ICogc2NhbGFyLFxyXG4gICAgeTogdi55ICogc2NhbGFyXHJcbiAgfSksXHJcbiAgXHJcbiAgZG90OiAoYTogVmVjdG9yLCBiOiBWZWN0b3IpOiBudW1iZXIgPT4gYS54ICogYi54ICsgYS55ICogYi55LFxyXG4gIFxyXG4gIG1hZ25pdHVkZTogKHY6IFZlY3Rvcik6IG51bWJlciA9PiBNYXRoLnNxcnQodi54ICogdi54ICsgdi55ICogdi55KSxcclxuICBcclxuICBub3JtYWxpemU6ICh2OiBWZWN0b3IpOiBWZWN0b3IgPT4ge1xyXG4gICAgY29uc3QgbWFnID0gVmVjdG9yLm1hZ25pdHVkZSh2KVxyXG4gICAgaWYgKG1hZyA9PT0gMCkgcmV0dXJuIFZlY3Rvci5jcmVhdGUoKVxyXG4gICAgcmV0dXJuIFZlY3Rvci5tdWx0aXBseSh2LCAxIC8gbWFnKVxyXG4gIH0sXHJcbiAgXHJcbiAgZGlzdGFuY2U6IChhOiBWZWN0b3IsIGI6IFZlY3Rvcik6IG51bWJlciA9PiB7XHJcbiAgICBjb25zdCBkaWZmID0gVmVjdG9yLnN1YnRyYWN0KGEsIGIpXHJcbiAgICByZXR1cm4gVmVjdG9yLm1hZ25pdHVkZShkaWZmKVxyXG4gIH0sXHJcbiAgXHJcbiAgbGVycDogKGE6IFZlY3RvciwgYjogVmVjdG9yLCB0OiBudW1iZXIpOiBWZWN0b3IgPT4gKHtcclxuICAgIHg6IGEueCArIChiLnggLSBhLngpICogdCxcclxuICAgIHk6IGEueSArIChiLnkgLSBhLnkpICogdFxyXG4gIH0pLFxyXG4gIFxyXG4gIHJvdGF0ZTogKHY6IFZlY3RvciwgYW5nbGU6IG51bWJlcik6IFZlY3RvciA9PiB7XHJcbiAgICBjb25zdCBjb3MgPSBNYXRoLmNvcyhhbmdsZSlcclxuICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogdi54ICogY29zIC0gdi55ICogc2luLFxyXG4gICAgICB5OiB2LnggKiBzaW4gKyB2LnkgKiBjb3NcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIFBoeXNpY3Mgc2ltdWxhdGlvbiBmdW5jdGlvbnNcclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVBoeXNpY3NXb3JsZCh3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IFBoeXNpY3NXb3JsZCB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGVudGl0aWVzOiBuZXcgTWFwKCksXHJcbiAgICBncmF2aXR5OiBWZWN0b3IuY3JlYXRlKDAsIDApLCAvLyBObyBncmF2aXR5IGJ5IGRlZmF1bHQgZm9yIHRvcC1kb3duIGFyZW5hXHJcbiAgICBhaXJGcmljdGlvbjogMC45OSxcclxuICAgIHRpbWVBY2N1bXVsYXRvcjogMCxcclxuICAgIGZpeGVkVGltZVN0ZXA6IDEgLyA2MCwgLy8gNjAgRlBTIHBoeXNpY3NcclxuICAgIGJvdW5kczogeyB3aWR0aCwgaGVpZ2h0IH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDaXJjbGVFbnRpdHkoXHJcbiAgaWQ6IHN0cmluZyxcclxuICB4OiBudW1iZXIsXHJcbiAgeTogbnVtYmVyLFxyXG4gIHJhZGl1czogbnVtYmVyLFxyXG4gIHR5cGU6IENpcmNsZUVudGl0eVsndHlwZSddID0gJ3BsYXllcidcclxuKTogQ2lyY2xlRW50aXR5IHtcclxuICByZXR1cm4ge1xyXG4gICAgaWQsXHJcbiAgICBwb3NpdGlvbjogVmVjdG9yLmNyZWF0ZSh4LCB5KSxcclxuICAgIHZlbG9jaXR5OiBWZWN0b3IuY3JlYXRlKCksXHJcbiAgICBhY2NlbGVyYXRpb246IFZlY3Rvci5jcmVhdGUoKSxcclxuICAgIHJhZGl1cyxcclxuICAgIG1hc3M6IE1hdGguUEkgKiByYWRpdXMgKiByYWRpdXMsIC8vIEFyZWEtYmFzZWQgbWFzc1xyXG4gICAgaGVhbHRoOiAxMDAsXHJcbiAgICBtYXhIZWFsdGg6IDEwMCxcclxuICAgIGRhbWFnZTogMjAsXHJcbiAgICByZXN0aXR1dGlvbjogMC45NSwgLy8gSW5jcmVhc2VkIGJvdW5jaW5nXHJcbiAgICBmcmljdGlvbjogMC45OCwgLy8gUmVkdWNlZCBmcmljdGlvbiBmb3IgZmFzdGVyIG1vdmVtZW50XHJcbiAgICBpc1N0YXRpYzogZmFsc2UsXHJcbiAgICB0eXBlLFxyXG4gICAgaW52dWxuZXJhYmxlVW50aWw6IDBcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9qZWN0aWxlKFxyXG4gIGlkOiBzdHJpbmcsXHJcbiAgeDogbnVtYmVyLFxyXG4gIHk6IG51bWJlcixcclxuICBkaXJlY3Rpb246IFZlY3RvcixcclxuICBzcGVlZDogbnVtYmVyLFxyXG4gIG93bmVySWQ6IHN0cmluZyxcclxuICBsaWZldGltZTogbnVtYmVyID0gMzAwMFxyXG4pOiBQcm9qZWN0aWxlIHtcclxuICBjb25zdCB2ZWxvY2l0eSA9IFZlY3Rvci5tdWx0aXBseShWZWN0b3Iubm9ybWFsaXplKGRpcmVjdGlvbiksIHNwZWVkKVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBpZCxcclxuICAgIHBvc2l0aW9uOiBWZWN0b3IuY3JlYXRlKHgsIHkpLFxyXG4gICAgdmVsb2NpdHksXHJcbiAgICBhY2NlbGVyYXRpb246IFZlY3Rvci5jcmVhdGUoKSxcclxuICAgIHJhZGl1czogNSxcclxuICAgIG1hc3M6IDEsXHJcbiAgICBoZWFsdGg6IDEsXHJcbiAgICBtYXhIZWFsdGg6IDEsXHJcbiAgICBkYW1hZ2U6IDEwLCAvLyBSZWR1Y2VkIGRlZmF1bHQgZGFtYWdlIGZyb20gMjUgdG8gMTBcclxuICAgIHJlc3RpdHV0aW9uOiAwLjIsXHJcbiAgICBmcmljdGlvbjogMSwgLy8gTm8gZnJpY3Rpb24gZm9yIHByb2plY3RpbGVzXHJcbiAgICBpc1N0YXRpYzogZmFsc2UsXHJcbiAgICB0eXBlOiAncHJvamVjdGlsZScsXHJcbiAgICBvd25lcklkLFxyXG4gICAgc3BlZWQsXHJcbiAgICBsaWZldGltZSxcclxuICAgIHBpZXJjaW5nOiAwLFxyXG4gICAgaGl0c1JlbWFpbmluZzogMVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ29sbGlzaW9uIGRldGVjdGlvblxyXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0Q29sbGlzaW9uKGE6IENpcmNsZUVudGl0eSwgYjogQ2lyY2xlRW50aXR5KTogQ29sbGlzaW9uIHwgbnVsbCB7XHJcbiAgY29uc3QgZGlzdGFuY2UgPSBWZWN0b3IuZGlzdGFuY2UoYS5wb3NpdGlvbiwgYi5wb3NpdGlvbilcclxuICBjb25zdCBtaW5EaXN0YW5jZSA9IGEucmFkaXVzICsgYi5yYWRpdXNcclxuICBcclxuICBpZiAoZGlzdGFuY2UgPj0gbWluRGlzdGFuY2UpIHtcclxuICAgIHJldHVybiBudWxsIC8vIE5vIGNvbGxpc2lvblxyXG4gIH1cclxuICBcclxuICBjb25zdCBub3JtYWwgPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5zdWJ0cmFjdChiLnBvc2l0aW9uLCBhLnBvc2l0aW9uKSlcclxuICBjb25zdCBwZW5ldHJhdGlvbiA9IG1pbkRpc3RhbmNlIC0gZGlzdGFuY2VcclxuICBjb25zdCByZWxhdGl2ZVZlbG9jaXR5ID0gVmVjdG9yLm1hZ25pdHVkZShWZWN0b3Iuc3VidHJhY3QoYS52ZWxvY2l0eSwgYi52ZWxvY2l0eSkpXHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGVudGl0eUE6IGEsXHJcbiAgICBlbnRpdHlCOiBiLFxyXG4gICAgbm9ybWFsLFxyXG4gICAgcGVuZXRyYXRpb24sXHJcbiAgICByZWxhdGl2ZVZlbG9jaXR5XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDb2xsaXNpb24gcmVzcG9uc2Ugd2l0aCBtb21lbnR1bS1iYXNlZCBkYW1hZ2VcclxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVDb2xsaXNpb24oY29sbGlzaW9uOiBDb2xsaXNpb24sIHdvcmxkOiBQaHlzaWNzV29ybGQpOiB2b2lkIHtcclxuICBjb25zdCB7IGVudGl0eUEsIGVudGl0eUIsIG5vcm1hbCwgcGVuZXRyYXRpb24sIHJlbGF0aXZlVmVsb2NpdHkgfSA9IGNvbGxpc2lvblxyXG4gIFxyXG4gIC8vIFNraXAgaWYgZWl0aGVyIGVudGl0eSBpcyBzdGF0aWMgYW5kIHRoZSBvdGhlciBpcyBhIHByb2plY3RpbGVcclxuICBpZiAoKGVudGl0eUEuaXNTdGF0aWMgfHwgZW50aXR5Qi5pc1N0YXRpYykgJiYgXHJcbiAgICAgIChlbnRpdHlBLnR5cGUgPT09ICdwcm9qZWN0aWxlJyB8fCBlbnRpdHlCLnR5cGUgPT09ICdwcm9qZWN0aWxlJykpIHtcclxuICAgIHJldHVyblxyXG4gIH1cclxuICBcclxuICAvLyBQb3NpdGlvbmFsIGNvcnJlY3Rpb24gdG8gcHJldmVudCBvdmVybGFwXHJcbiAgY29uc3QgY29ycmVjdGlvblBlcmNlbnQgPSAwLjhcclxuICBjb25zdCBjb3JyZWN0aW9uID0gVmVjdG9yLm11bHRpcGx5KG5vcm1hbCwgcGVuZXRyYXRpb24gKiBjb3JyZWN0aW9uUGVyY2VudClcclxuICBcclxuICBpZiAoIWVudGl0eUEuaXNTdGF0aWMgJiYgIWVudGl0eUIuaXNTdGF0aWMpIHtcclxuICAgIGNvbnN0IHRvdGFsTWFzcyA9IGVudGl0eUEubWFzcyArIGVudGl0eUIubWFzc1xyXG4gICAgZW50aXR5QS5wb3NpdGlvbiA9IFZlY3Rvci5zdWJ0cmFjdChlbnRpdHlBLnBvc2l0aW9uLCBWZWN0b3IubXVsdGlwbHkoY29ycmVjdGlvbiwgZW50aXR5Qi5tYXNzIC8gdG90YWxNYXNzKSlcclxuICAgIGVudGl0eUIucG9zaXRpb24gPSBWZWN0b3IuYWRkKGVudGl0eUIucG9zaXRpb24sIFZlY3Rvci5tdWx0aXBseShjb3JyZWN0aW9uLCBlbnRpdHlBLm1hc3MgLyB0b3RhbE1hc3MpKVxyXG4gIH0gZWxzZSBpZiAoIWVudGl0eUEuaXNTdGF0aWMpIHtcclxuICAgIGVudGl0eUEucG9zaXRpb24gPSBWZWN0b3Iuc3VidHJhY3QoZW50aXR5QS5wb3NpdGlvbiwgY29ycmVjdGlvbilcclxuICB9IGVsc2UgaWYgKCFlbnRpdHlCLmlzU3RhdGljKSB7XHJcbiAgICBlbnRpdHlCLnBvc2l0aW9uID0gVmVjdG9yLmFkZChlbnRpdHlCLnBvc2l0aW9uLCBjb3JyZWN0aW9uKVxyXG4gIH1cclxuICBcclxuICAvLyBDYWxjdWxhdGUgbW9tZW50dW0tYmFzZWQgZGFtYWdlIChyZWR1Y2VkIGZvciBsb25nZXIgYmF0dGxlcylcclxuICBjb25zdCBiYXNlRGFtYWdlID0gTWF0aC5tYXgoZW50aXR5QS5kYW1hZ2UsIGVudGl0eUIuZGFtYWdlKVxyXG4gIGNvbnN0IG1vbWVudHVtRGFtYWdlID0gYmFzZURhbWFnZSAqIDAuMyAqICgxICsgTWF0aC5taW4ocmVsYXRpdmVWZWxvY2l0eSAvIDYwMCwgMSkpIC8vIFJlZHVjZWQgYnkgNzAlXHJcbiAgXHJcbiAgLy8gQXBwbHkgZGFtYWdlIHdpdGggaW52dWxuZXJhYmlsaXR5IGZyYW1lc1xyXG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxyXG4gIFxyXG4gIGlmIChlbnRpdHlBLnR5cGUgIT09ICdwcm9qZWN0aWxlJyAmJiBlbnRpdHlCLnR5cGUgIT09ICdwaWNrdXAnICYmIFxyXG4gICAgICBlbnRpdHlBLmludnVsbmVyYWJsZVVudGlsISA8IGN1cnJlbnRUaW1lKSB7XHJcbiAgICBlbnRpdHlBLmhlYWx0aCA9IE1hdGgubWF4KDAsIGVudGl0eUEuaGVhbHRoIC0gbW9tZW50dW1EYW1hZ2UpXHJcbiAgICBlbnRpdHlBLmludnVsbmVyYWJsZVVudGlsID0gY3VycmVudFRpbWUgKyA1MDAgLy8gNTAwbXMgaW1tdW5pdHlcclxuICB9XHJcbiAgXHJcbiAgaWYgKGVudGl0eUIudHlwZSAhPT0gJ3Byb2plY3RpbGUnICYmIGVudGl0eUEudHlwZSAhPT0gJ3BpY2t1cCcgJiYgXHJcbiAgICAgIGVudGl0eUIuaW52dWxuZXJhYmxlVW50aWwhIDwgY3VycmVudFRpbWUpIHtcclxuICAgIGVudGl0eUIuaGVhbHRoID0gTWF0aC5tYXgoMCwgZW50aXR5Qi5oZWFsdGggLSBtb21lbnR1bURhbWFnZSlcclxuICAgIGVudGl0eUIuaW52dWxuZXJhYmxlVW50aWwgPSBjdXJyZW50VGltZSArIDUwMFxyXG4gIH1cclxuICBcclxuICAvLyBFbGFzdGljIGNvbGxpc2lvbiByZXNwb25zZVxyXG4gIGlmICghZW50aXR5QS5pc1N0YXRpYyAmJiAhZW50aXR5Qi5pc1N0YXRpYykge1xyXG4gICAgY29uc3QgcmVsYXRpdmVWZWwgPSBWZWN0b3Iuc3VidHJhY3QoZW50aXR5QS52ZWxvY2l0eSwgZW50aXR5Qi52ZWxvY2l0eSlcclxuICAgIGNvbnN0IHZlbEFsb25nTm9ybWFsID0gVmVjdG9yLmRvdChyZWxhdGl2ZVZlbCwgbm9ybWFsKVxyXG4gICAgXHJcbiAgICBpZiAodmVsQWxvbmdOb3JtYWwgPiAwKSByZXR1cm4gLy8gT2JqZWN0cyBzZXBhcmF0aW5nXHJcbiAgICBcclxuICAgIGNvbnN0IHJlc3RpdHV0aW9uID0gTWF0aC5tYXgoZW50aXR5QS5yZXN0aXR1dGlvbiwgZW50aXR5Qi5yZXN0aXR1dGlvbikgKiAwLjkgLy8gUmVhbGlzdGljIGJvdW5jaW5nXHJcbiAgICBjb25zdCBpbXB1bHNlU2NhbGFyID0gLSgxICsgcmVzdGl0dXRpb24pICogdmVsQWxvbmdOb3JtYWwgLyAoMS9lbnRpdHlBLm1hc3MgKyAxL2VudGl0eUIubWFzcylcclxuICAgIFxyXG4gICAgY29uc3QgaW1wdWxzZSA9IFZlY3Rvci5tdWx0aXBseShub3JtYWwsIGltcHVsc2VTY2FsYXIpXHJcbiAgICBcclxuICAgIC8vIFNtYWxsIHJhbmRvbSB2YXJpYXRpb24gZm9yIG5hdHVyYWwgbW92ZW1lbnRcclxuICAgIGNvbnN0IHJhbmRvbUJvb3N0ID0gVmVjdG9yLmNyZWF0ZShcclxuICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMTAsXHJcbiAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDEwXHJcbiAgICApXHJcbiAgICBcclxuICAgIGVudGl0eUEudmVsb2NpdHkgPSBWZWN0b3IuYWRkKGVudGl0eUEudmVsb2NpdHksIFZlY3Rvci5hZGQoVmVjdG9yLm11bHRpcGx5KGltcHVsc2UsIDEvZW50aXR5QS5tYXNzKSwgcmFuZG9tQm9vc3QpKVxyXG4gICAgZW50aXR5Qi52ZWxvY2l0eSA9IFZlY3Rvci5zdWJ0cmFjdChlbnRpdHlCLnZlbG9jaXR5LCBWZWN0b3IuYWRkKFZlY3Rvci5tdWx0aXBseShpbXB1bHNlLCAxL2VudGl0eUIubWFzcyksIHJhbmRvbUJvb3N0KSlcclxuICB9XHJcbiAgXHJcbiAgLy8gSGFuZGxlIHByb2plY3RpbGUgaGl0c1xyXG4gIGlmIChlbnRpdHlBLnR5cGUgPT09ICdwcm9qZWN0aWxlJyB8fCBlbnRpdHlCLnR5cGUgPT09ICdwcm9qZWN0aWxlJykge1xyXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IGVudGl0eUEudHlwZSA9PT0gJ3Byb2plY3RpbGUnID8gZW50aXR5QSBhcyBQcm9qZWN0aWxlIDogZW50aXR5QiBhcyBQcm9qZWN0aWxlXHJcbiAgICBjb25zdCB0YXJnZXQgPSBlbnRpdHlBLnR5cGUgPT09ICdwcm9qZWN0aWxlJyA/IGVudGl0eUIgOiBlbnRpdHlBXHJcbiAgICBcclxuICAgIC8vIFByZXZlbnQgZnJpZW5kbHkgZmlyZSAtIHByb2plY3RpbGVzIGRvbid0IGh1cnQgdGhlaXIgb3duZXJcclxuICAgIGlmIChwcm9qZWN0aWxlLm93bmVySWQgPT09IHRhcmdldC5pZCkge1xyXG4gICAgICByZXR1cm4gLy8gU2tpcCBkYW1hZ2UgaWYgcHJvamVjdGlsZSBoaXRzIGl0cyBvd25lclxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBcHBseSBkYW1hZ2UgdG8gdGFyZ2V0XHJcbiAgICBpZiAodGFyZ2V0LnR5cGUgPT09ICdwbGF5ZXInICYmIHRhcmdldC5oZWFsdGggPiAwKSB7XHJcbiAgICAgIGNvbnN0IHByb2plY3RpbGVEYW1hZ2UgPSBwcm9qZWN0aWxlLmRhbWFnZSB8fCAxMCAvLyBSZWR1Y2VkIGRlZmF1bHQgZnJvbSAyNSB0byAxMFxyXG4gICAgICB0YXJnZXQuaGVhbHRoID0gTWF0aC5tYXgoMCwgdGFyZ2V0LmhlYWx0aCAtIHByb2plY3RpbGVEYW1hZ2UpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBmb3IgY3JpdGljYWwgaGl0IChoaWdoIHZlbG9jaXR5IGltcGFjdClcclxuICAgICAgY29uc3QgaXNDcml0aWNhbEhpdCA9IHJlbGF0aXZlVmVsb2NpdHkgPiA0MDBcclxuICAgICAgXHJcbiAgICAgIGlmIChpc0NyaXRpY2FsSGl0ICYmIHRhcmdldC53ZWFwb25JZCAmJiB0YXJnZXQudHlwZSA9PT0gJ3BsYXllcicpIHtcclxuICAgICAgICAvLyBXZWFwb24gc3dhcCBvbiBjcml0aWNhbCBoaXQgLSBkcm9wIHdlYXBvbiBhcyBwaWNrdXBcclxuICAgICAgICBzcGF3bldlYXBvblBpY2t1cCh3b3JsZCwgdGFyZ2V0LnBvc2l0aW9uLCB0YXJnZXQud2VhcG9uSWQpXHJcbiAgICAgICAgdGFyZ2V0LndlYXBvbklkID0gdW5kZWZpbmVkXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gUmVtb3ZlIHByb2plY3RpbGUgb3IgcmVkdWNlIHBpZXJjaW5nXHJcbiAgICBpZiAocHJvamVjdGlsZS5oaXRzUmVtYWluaW5nIDw9IDEpIHtcclxuICAgICAgd29ybGQuZW50aXRpZXMuZGVsZXRlKHByb2plY3RpbGUuaWQpXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwcm9qZWN0aWxlLmhpdHNSZW1haW5pbmctLVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ2hhaW4ga25vY2tiYWNrIC0gd2hlbiBtb3ZpbmcgY2lyY2xlIGZvcmNlcyBhbm90aGVyIGludG8gYSB0aGlyZFxyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlDaGFpbktub2NrYmFjayh3b3JsZDogUGh5c2ljc1dvcmxkLCBjb2xsaXNpb246IENvbGxpc2lvbik6IHZvaWQge1xyXG4gIGNvbnN0IHsgZW50aXR5QSwgZW50aXR5QiB9ID0gY29sbGlzaW9uXHJcbiAgY29uc3QgcHVzaGluZ0VudGl0eSA9IFZlY3Rvci5tYWduaXR1ZGUoZW50aXR5QS52ZWxvY2l0eSkgPiBWZWN0b3IubWFnbml0dWRlKGVudGl0eUIudmVsb2NpdHkpID8gZW50aXR5QSA6IGVudGl0eUJcclxuICBjb25zdCBwdXNoZWRFbnRpdHkgPSBwdXNoaW5nRW50aXR5ID09PSBlbnRpdHlBID8gZW50aXR5QiA6IGVudGl0eUFcclxuICBcclxuICAvLyBGaW5kIGVudGl0aWVzIHRoYXQgbWlnaHQgYmUgaGl0IGJ5IHRoZSBwdXNoZWQgZW50aXR5XHJcbiAgY29uc3QgY2hhaW5SYWRpdXMgPSBwdXNoZWRFbnRpdHkucmFkaXVzICsgNTAgLy8gRGV0ZWN0aW9uIHJhbmdlXHJcbiAgXHJcbiAgZm9yIChjb25zdCBbaWQsIGVudGl0eV0gb2Ygd29ybGQuZW50aXRpZXMpIHtcclxuICAgIGlmIChlbnRpdHkuaWQgPT09IHB1c2hlZEVudGl0eS5pZCB8fCBlbnRpdHkuaWQgPT09IHB1c2hpbmdFbnRpdHkuaWQpIGNvbnRpbnVlXHJcbiAgICBcclxuICAgIGNvbnN0IGRpc3RhbmNlID0gVmVjdG9yLmRpc3RhbmNlKHB1c2hlZEVudGl0eS5wb3NpdGlvbiwgZW50aXR5LnBvc2l0aW9uKVxyXG4gICAgaWYgKGRpc3RhbmNlIDw9IGNoYWluUmFkaXVzKSB7XHJcbiAgICAgIC8vIEFwcGx5IHJlZHVjZWQga25vY2tiYWNrXHJcbiAgICAgIGNvbnN0IGtub2NrYmFja0RpcmVjdGlvbiA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnN1YnRyYWN0KGVudGl0eS5wb3NpdGlvbiwgcHVzaGVkRW50aXR5LnBvc2l0aW9uKSlcclxuICAgICAgY29uc3Qga25vY2tiYWNrRm9yY2UgPSBWZWN0b3IubWFnbml0dWRlKHB1c2hlZEVudGl0eS52ZWxvY2l0eSkgKiAwLjMgLy8gUmVkdWNlZCBmb3JjZVxyXG4gICAgICBcclxuICAgICAgaWYgKCFlbnRpdHkuaXNTdGF0aWMpIHtcclxuICAgICAgICBlbnRpdHkudmVsb2NpdHkgPSBWZWN0b3IuYWRkKGVudGl0eS52ZWxvY2l0eSwgVmVjdG9yLm11bHRpcGx5KGtub2NrYmFja0RpcmVjdGlvbiwga25vY2tiYWNrRm9yY2UpKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBzcGF3bldlYXBvblBpY2t1cCh3b3JsZDogUGh5c2ljc1dvcmxkLCBwb3NpdGlvbjogVmVjdG9yLCB3ZWFwb25JZDogc3RyaW5nKTogdm9pZCB7XHJcbiAgY29uc3QgcGlja3VwID0gY3JlYXRlQ2lyY2xlRW50aXR5KFxyXG4gICAgYHBpY2t1cF8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDkpfWAsXHJcbiAgICBwb3NpdGlvbi54LFxyXG4gICAgcG9zaXRpb24ueSxcclxuICAgIDE1LFxyXG4gICAgJ3BpY2t1cCdcclxuICApXHJcbiAgcGlja3VwLndlYXBvbklkID0gd2VhcG9uSWRcclxuICBwaWNrdXAuaXNTdGF0aWMgPSB0cnVlXHJcbiAgcGlja3VwLmxpZmV0aW1lID0gMTUwMDAgLy8gMTUgc2Vjb25kc1xyXG4gIFxyXG4gIHdvcmxkLmVudGl0aWVzLnNldChwaWNrdXAuaWQsIHBpY2t1cClcclxufVxyXG5cclxuLy8gQXBwbHkgZnJpY3Rpb24gdG8gYWxsIGVudGl0aWVzXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUZyaWN0aW9uKHdvcmxkOiBQaHlzaWNzV29ybGQpOiB2b2lkIHtcclxuICBmb3IgKGNvbnN0IFtpZCwgZW50aXR5XSBvZiB3b3JsZC5lbnRpdGllcykge1xyXG4gICAgaWYgKCFlbnRpdHkuaXNTdGF0aWMgJiYgZW50aXR5LnR5cGUgIT09ICdwcm9qZWN0aWxlJykge1xyXG4gICAgICBlbnRpdHkudmVsb2NpdHkgPSBWZWN0b3IubXVsdGlwbHkoZW50aXR5LnZlbG9jaXR5LCBlbnRpdHkuZnJpY3Rpb24pXHJcbiAgICAgIFxyXG4gICAgICAvLyBTdG9wIHZlcnkgc2xvdyBtb3ZlbWVudCB0byBwcmV2ZW50IGppdHRlclxyXG4gICAgICBpZiAoVmVjdG9yLm1hZ25pdHVkZShlbnRpdHkudmVsb2NpdHkpIDwgMC4xKSB7XHJcbiAgICAgICAgZW50aXR5LnZlbG9jaXR5ID0gVmVjdG9yLmNyZWF0ZSgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIEludGVncmF0ZSBwb3NpdGlvbiBhbmQgdmVsb2NpdHkgdXNpbmcgVmVybGV0IGludGVncmF0aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBpbnRlZ3JhdGUoZW50aXR5OiBDaXJjbGVFbnRpdHksIGR0OiBudW1iZXIpOiB2b2lkIHtcclxuICBpZiAoZW50aXR5LmlzU3RhdGljKSByZXR1cm5cclxuICBcclxuICAvLyBBcHBseSBncmF2aXR5XHJcbiAgZW50aXR5LnZlbG9jaXR5ID0gVmVjdG9yLmFkZChlbnRpdHkudmVsb2NpdHksIFZlY3Rvci5tdWx0aXBseShlbnRpdHkuYWNjZWxlcmF0aW9uLCBkdCkpXHJcbiAgXHJcbiAgLy8gVXBkYXRlIHBvc2l0aW9uXHJcbiAgZW50aXR5LnBvc2l0aW9uID0gVmVjdG9yLmFkZChlbnRpdHkucG9zaXRpb24sIFZlY3Rvci5tdWx0aXBseShlbnRpdHkudmVsb2NpdHksIGR0KSlcclxuICBcclxuICAvLyBSZXNldCBhY2NlbGVyYXRpb24gZm9yIG5leHQgZnJhbWVcclxuICBlbnRpdHkuYWNjZWxlcmF0aW9uID0gVmVjdG9yLmNyZWF0ZSgpXHJcbn1cclxuXHJcbi8vIEJvdW5kYXJ5IGNvbGxpc2lvblxyXG5leHBvcnQgZnVuY3Rpb24gaGFuZGxlQm91bmRhcnlDb2xsaXNpb24oZW50aXR5OiBDaXJjbGVFbnRpdHksIGJvdW5kczogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9KTogdm9pZCB7XHJcbiAgaWYgKGVudGl0eS5pc1N0YXRpYykgcmV0dXJuXHJcbiAgXHJcbiAgLy8gUHJvamVjdGlsZXMgc2hvdWxkIGRpc2FwcGVhciB3aGVuIGhpdHRpbmcgd2FsbHMgKG1vcmUgcmVhbGlzdGljKVxyXG4gIGlmIChlbnRpdHkudHlwZSA9PT0gJ3Byb2plY3RpbGUnKSB7XHJcbiAgICBpZiAoZW50aXR5LnBvc2l0aW9uLnggLSBlbnRpdHkucmFkaXVzIDw9IDAgfHwgXHJcbiAgICAgICAgZW50aXR5LnBvc2l0aW9uLnggKyBlbnRpdHkucmFkaXVzID49IGJvdW5kcy53aWR0aCB8fFxyXG4gICAgICAgIGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LnJhZGl1cyA8PSAwIHx8IFxyXG4gICAgICAgIGVudGl0eS5wb3NpdGlvbi55ICsgZW50aXR5LnJhZGl1cyA+PSBib3VuZHMuaGVpZ2h0KSB7XHJcbiAgICAgIC8vIE1hcmsgZm9yIHJlbW92YWwgYnkgc2V0dGluZyBoZWFsdGggdG8gMFxyXG4gICAgICBlbnRpdHkuaGVhbHRoID0gMFxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgY29uc3QgYm91bmNlRmFjdG9yID0gZW50aXR5LnJlc3RpdHV0aW9uICogMC45NSAvLyBTbGlnaHQgZW5lcmd5IGxvc3MgZm9yIHJlYWxpc3RpYyBib3VuY2luZ1xyXG4gIFxyXG4gIC8vIExlZnQgYm91bmRhcnlcclxuICBpZiAoZW50aXR5LnBvc2l0aW9uLnggLSBlbnRpdHkucmFkaXVzIDwgMCkge1xyXG4gICAgZW50aXR5LnBvc2l0aW9uLnggPSBlbnRpdHkucmFkaXVzXHJcbiAgICBlbnRpdHkudmVsb2NpdHkueCA9IC1lbnRpdHkudmVsb2NpdHkueCAqIGJvdW5jZUZhY3RvclxyXG4gICAgLy8gU21hbGwgcmFuZG9tIGNvbXBvbmVudCBmb3IgdmFyaWV0eVxyXG4gICAgZW50aXR5LnZlbG9jaXR5LnkgKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMjBcclxuICB9XHJcbiAgXHJcbiAgLy8gUmlnaHQgYm91bmRhcnlcclxuICBpZiAoZW50aXR5LnBvc2l0aW9uLnggKyBlbnRpdHkucmFkaXVzID4gYm91bmRzLndpZHRoKSB7XHJcbiAgICBlbnRpdHkucG9zaXRpb24ueCA9IGJvdW5kcy53aWR0aCAtIGVudGl0eS5yYWRpdXNcclxuICAgIGVudGl0eS52ZWxvY2l0eS54ID0gLWVudGl0eS52ZWxvY2l0eS54ICogYm91bmNlRmFjdG9yXHJcbiAgICAvLyBTbWFsbCByYW5kb20gY29tcG9uZW50IGZvciB2YXJpZXR5XHJcbiAgICBlbnRpdHkudmVsb2NpdHkueSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMFxyXG4gIH1cclxuICBcclxuICAvLyBUb3AgYm91bmRhcnlcclxuICBpZiAoZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkucmFkaXVzIDwgMCkge1xyXG4gICAgZW50aXR5LnBvc2l0aW9uLnkgPSBlbnRpdHkucmFkaXVzXHJcbiAgICBlbnRpdHkudmVsb2NpdHkueSA9IC1lbnRpdHkudmVsb2NpdHkueSAqIGJvdW5jZUZhY3RvclxyXG4gICAgLy8gU21hbGwgcmFuZG9tIGNvbXBvbmVudCBmb3IgdmFyaWV0eVxyXG4gICAgZW50aXR5LnZlbG9jaXR5LnggKz0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMjBcclxuICB9XHJcbiAgXHJcbiAgLy8gQm90dG9tIGJvdW5kYXJ5XHJcbiAgaWYgKGVudGl0eS5wb3NpdGlvbi55ICsgZW50aXR5LnJhZGl1cyA+IGJvdW5kcy5oZWlnaHQpIHtcclxuICAgIGVudGl0eS5wb3NpdGlvbi55ID0gYm91bmRzLmhlaWdodCAtIGVudGl0eS5yYWRpdXNcclxuICAgIGVudGl0eS52ZWxvY2l0eS55ID0gLWVudGl0eS52ZWxvY2l0eS55ICogYm91bmNlRmFjdG9yXHJcbiAgICAvLyBTbWFsbCByYW5kb20gY29tcG9uZW50IGZvciB2YXJpZXR5XHJcbiAgICBlbnRpdHkudmVsb2NpdHkueCArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMFxyXG4gIH1cclxufVxyXG5cclxuLy8gTWFpbiBwaHlzaWNzIHNpbXVsYXRpb24gc3RlcFxyXG5leHBvcnQgZnVuY3Rpb24gc2ltdWxhdGVTdGVwKHdvcmxkOiBQaHlzaWNzV29ybGQsIGRlbHRhVGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgd29ybGQudGltZUFjY3VtdWxhdG9yICs9IGRlbHRhVGltZVxyXG4gIFxyXG4gIC8vIEZpeGVkIHRpbWVzdGVwIHdpdGggYWNjdW11bGF0b3IgcGF0dGVybiBmb3IgZGV0ZXJtaW5pc21cclxuICB3aGlsZSAod29ybGQudGltZUFjY3VtdWxhdG9yID49IHdvcmxkLmZpeGVkVGltZVN0ZXApIHtcclxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxyXG4gICAgXHJcbiAgICAvLyBSZW1vdmUgZXhwaXJlZCBlbnRpdGllc1xyXG4gICAgZm9yIChjb25zdCBbaWQsIGVudGl0eV0gb2Ygd29ybGQuZW50aXRpZXMpIHtcclxuICAgICAgaWYgKGVudGl0eS5saWZldGltZSAmJiBjdXJyZW50VGltZSA+IChlbnRpdHkubGlmZXRpbWUgKyAoZW50aXR5IGFzIGFueSkuc3Bhd25UaW1lIHx8IDApKSB7XHJcbiAgICAgICAgd29ybGQuZW50aXRpZXMuZGVsZXRlKGlkKVxyXG4gICAgICAgIGNvbnRpbnVlXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFJlbW92ZSBkZWFkIGVudGl0aWVzXHJcbiAgICAgIGlmIChlbnRpdHkuaGVhbHRoIDw9IDApIHtcclxuICAgICAgICB3b3JsZC5lbnRpdGllcy5kZWxldGUoaWQpXHJcbiAgICAgICAgY29udGludWVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgd2VhcG9uIHN5c3RlbXMgYW5kIGVuZXJneVxyXG4gICAgZm9yIChjb25zdCBbaWQsIGVudGl0eV0gb2Ygd29ybGQuZW50aXRpZXMpIHtcclxuICAgICAgdXBkYXRlV2VhcG9uQ29vbGRvd25zKGVudGl0eSwgY3VycmVudFRpbWUpXHJcbiAgICAgIHJlZ2VuZXJhdGVFbmVyZ3koZW50aXR5LCB3b3JsZC5maXhlZFRpbWVTdGVwKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBVcGRhdGUgQUkgKHdpbGwgYmUgY2FsbGVkIHdpdGggd2VhcG9ucyBmcm9tIG91dHNpZGUpXHJcbiAgICBpZiAoKHdvcmxkIGFzIGFueSkud2VhcG9ucykge1xyXG4gICAgICBmb3IgKGNvbnN0IFtpZCwgZW50aXR5XSBvZiB3b3JsZC5lbnRpdGllcykge1xyXG4gICAgICAgIGlmIChlbnRpdHkuaGVhbHRoID4gMCkge1xyXG4gICAgICAgICAgdXBkYXRlQUkoZW50aXR5LCB3b3JsZCwgd29ybGQuZml4ZWRUaW1lU3RlcCwgKHdvcmxkIGFzIGFueSkud2VhcG9ucylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSW50ZWdyYXRpb24gc3RlcCAtIGhhbmRsZSBwcm9qZWN0aWxlcyBzZXBhcmF0ZWx5XHJcbiAgICBmb3IgKGNvbnN0IFtpZCwgZW50aXR5XSBvZiB3b3JsZC5lbnRpdGllcykge1xyXG4gICAgICBpZiAoZW50aXR5LnR5cGUgPT09ICdwcm9qZWN0aWxlJykge1xyXG4gICAgICAgIC8vIFByb2plY3RpbGVzIG9ubHkgdXBkYXRlIHBvc2l0aW9uLCBubyBwaHlzaWNzIGludGVyYWN0aW9uc1xyXG4gICAgICAgIGVudGl0eS5wb3NpdGlvbi54ICs9IGVudGl0eS52ZWxvY2l0eS54ICogd29ybGQuZml4ZWRUaW1lU3RlcFxyXG4gICAgICAgIGVudGl0eS5wb3NpdGlvbi55ICs9IGVudGl0eS52ZWxvY2l0eS55ICogd29ybGQuZml4ZWRUaW1lU3RlcFxyXG4gICAgICAgIC8vIENoZWNrIGJvdW5kYXJpZXMgZm9yIHByb2plY3RpbGVzIChyZW1vdmUgd2hlbiBoaXR0aW5nIHdhbGxzKVxyXG4gICAgICAgIGlmIChlbnRpdHkucG9zaXRpb24ueCAtIGVudGl0eS5yYWRpdXMgPD0gMCB8fCBcclxuICAgICAgICAgICAgZW50aXR5LnBvc2l0aW9uLnggKyBlbnRpdHkucmFkaXVzID49IHdvcmxkLmJvdW5kcy53aWR0aCB8fFxyXG4gICAgICAgICAgICBlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5yYWRpdXMgPD0gMCB8fCBcclxuICAgICAgICAgICAgZW50aXR5LnBvc2l0aW9uLnkgKyBlbnRpdHkucmFkaXVzID49IHdvcmxkLmJvdW5kcy5oZWlnaHQpIHtcclxuICAgICAgICAgIGVudGl0eS5oZWFsdGggPSAwIC8vIE1hcmsgZm9yIHJlbW92YWxcclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gTm9ybWFsIHBoeXNpY3MgZm9yIG5vbi1wcm9qZWN0aWxlc1xyXG4gICAgICAgIGludGVncmF0ZShlbnRpdHksIHdvcmxkLmZpeGVkVGltZVN0ZXApXHJcbiAgICAgICAgaGFuZGxlQm91bmRhcnlDb2xsaXNpb24oZW50aXR5LCB3b3JsZC5ib3VuZHMpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQ29sbGlzaW9uIGRldGVjdGlvbiBhbmQgcmVzcG9uc2VcclxuICAgIGNvbnN0IGVudGl0aWVzID0gQXJyYXkuZnJvbSh3b3JsZC5lbnRpdGllcy52YWx1ZXMoKSlcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50aXRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgZW50aXRpZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBjb25zdCBlbnRpdHlBID0gZW50aXRpZXNbaV1cclxuICAgICAgICBjb25zdCBlbnRpdHlCID0gZW50aXRpZXNbal1cclxuICAgICAgICBcclxuICAgICAgICAvLyBTa2lwIHByb2plY3RpbGUtdG8tcHJvamVjdGlsZSBjb2xsaXNpb25zXHJcbiAgICAgICAgaWYgKGVudGl0eUEudHlwZSA9PT0gJ3Byb2plY3RpbGUnICYmIGVudGl0eUIudHlwZSA9PT0gJ3Byb2plY3RpbGUnKSB7XHJcbiAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBjb2xsaXNpb24gPSBkZXRlY3RDb2xsaXNpb24oZW50aXR5QSwgZW50aXR5QilcclxuICAgICAgICBpZiAoY29sbGlzaW9uKSB7XHJcbiAgICAgICAgICByZXNvbHZlQ29sbGlzaW9uKGNvbGxpc2lvbiwgd29ybGQpXHJcbiAgICAgICAgICAvLyBPbmx5IGFwcGx5IGNoYWluIGtub2NrYmFjayBmb3Igbm9uLXByb2plY3RpbGUgZW50aXRpZXNcclxuICAgICAgICAgIGlmIChlbnRpdHlBLnR5cGUgIT09ICdwcm9qZWN0aWxlJyAmJiBlbnRpdHlCLnR5cGUgIT09ICdwcm9qZWN0aWxlJykge1xyXG4gICAgICAgICAgICBhcHBseUNoYWluS25vY2tiYWNrKHdvcmxkLCBjb2xsaXNpb24pXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEFwcGx5IGZyaWN0aW9uXHJcbiAgICBhcHBseUZyaWN0aW9uKHdvcmxkKVxyXG4gICAgXHJcbiAgICB3b3JsZC50aW1lQWNjdW11bGF0b3IgLT0gd29ybGQuZml4ZWRUaW1lU3RlcFxyXG4gIH1cclxufVxyXG5cclxuLy8gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGV4dGVybmFsIHVzZVxyXG5leHBvcnQgZnVuY3Rpb24gYWRkRm9yY2UoZW50aXR5OiBDaXJjbGVFbnRpdHksIGZvcmNlOiBWZWN0b3IpOiB2b2lkIHtcclxuICBpZiAoIWVudGl0eS5pc1N0YXRpYykge1xyXG4gICAgZW50aXR5LmFjY2VsZXJhdGlvbiA9IFZlY3Rvci5hZGQoZW50aXR5LmFjY2VsZXJhdGlvbiwgVmVjdG9yLm11bHRpcGx5KGZvcmNlLCAxIC8gZW50aXR5Lm1hc3MpKVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFZlbG9jaXR5KGVudGl0eTogQ2lyY2xlRW50aXR5LCB2ZWxvY2l0eTogVmVjdG9yKTogdm9pZCB7XHJcbiAgaWYgKCFlbnRpdHkuaXNTdGF0aWMpIHtcclxuICAgIGVudGl0eS52ZWxvY2l0eSA9IHZlbG9jaXR5XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdGVsZXBvcnQoZW50aXR5OiBDaXJjbGVFbnRpdHksIHBvc2l0aW9uOiBWZWN0b3IpOiB2b2lkIHtcclxuICBlbnRpdHkucG9zaXRpb24gPSBwb3NpdGlvblxyXG59XHJcblxyXG4vLyBXZWFwb24gc3lzdGVtIGludGVncmF0aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBmaXJlV2VhcG9uKHdvcmxkOiBQaHlzaWNzV29ybGQsIGVudGl0eUlkOiBzdHJpbmcsIHdlYXBvbkRhdGE6IGFueSwgdGFyZ2V0RGlyZWN0aW9uOiBWZWN0b3IsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBib29sZWFuIHtcclxuICBjb25zdCBlbnRpdHkgPSB3b3JsZC5lbnRpdGllcy5nZXQoZW50aXR5SWQpXHJcbiAgaWYgKCFlbnRpdHkpIHJldHVybiBmYWxzZVxyXG4gIFxyXG4gIC8vIENoZWNrIGNvb2xkb3duIGFuZCBlbmVyZ3lcclxuICBjb25zdCBjb29sZG93bkVuZCA9IGVudGl0eS53ZWFwb25Db29sZG93bnM/LmdldCh3ZWFwb25EYXRhLmlkKSB8fCAwXHJcbiAgaWYgKGN1cnJlbnRUaW1lIDwgY29vbGRvd25FbmQpIHJldHVybiBmYWxzZVxyXG4gIGlmICgoZW50aXR5LmVuZXJneSB8fCAwKSA8IHdlYXBvbkRhdGEuY29zdCkgcmV0dXJuIGZhbHNlXHJcbiAgXHJcbiAgLy8gVXBkYXRlIGVudGl0eSBjb29sZG93biBhbmQgZW5lcmd5XHJcbiAgaWYgKCFlbnRpdHkud2VhcG9uQ29vbGRvd25zKSBlbnRpdHkud2VhcG9uQ29vbGRvd25zID0gbmV3IE1hcCgpXHJcbiAgZW50aXR5LndlYXBvbkNvb2xkb3ducy5zZXQod2VhcG9uRGF0YS5pZCwgY3VycmVudFRpbWUgKyB3ZWFwb25EYXRhLmNvb2xkb3duTXMpXHJcbiAgZW50aXR5LmVuZXJneSA9IChlbnRpdHkuZW5lcmd5IHx8IDApIC0gd2VhcG9uRGF0YS5jb3N0XHJcbiAgXHJcbiAgLy8gQ3JlYXRlIHdlYXBvbiBlZmZlY3RcclxuICBpZiAod2VhcG9uRGF0YS50eXBlID09PSAncHJvamVjdGlsZScpIHtcclxuICAgIGNvbnN0IHByb2plY3RpbGUgPSBjcmVhdGVXZWFwb25Qcm9qZWN0aWxlKGVudGl0eSwgd2VhcG9uRGF0YSwgdGFyZ2V0RGlyZWN0aW9uLCBjdXJyZW50VGltZSlcclxuICAgIHdvcmxkLmVudGl0aWVzLnNldChwcm9qZWN0aWxlLmlkLCBwcm9qZWN0aWxlKVxyXG4gIH0gZWxzZSBpZiAod2VhcG9uRGF0YS50eXBlID09PSAnYXVyYScpIHtcclxuICAgIGNvbnN0IGF1cmEgPSBjcmVhdGVXZWFwb25BdXJhKGVudGl0eSwgd2VhcG9uRGF0YSwgY3VycmVudFRpbWUpXHJcbiAgICB3b3JsZC5lbnRpdGllcy5zZXQoYXVyYS5pZCwgYXVyYSlcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlV2VhcG9uUHJvamVjdGlsZShvd25lcjogQ2lyY2xlRW50aXR5LCB3ZWFwb25EYXRhOiBhbnksIGRpcmVjdGlvbjogVmVjdG9yLCBjdXJyZW50VGltZTogbnVtYmVyKTogV2VhcG9uUHJvamVjdGlsZSB7XHJcbiAgY29uc3Qgbm9ybWFsaXplZERpciA9IFZlY3Rvci5ub3JtYWxpemUoZGlyZWN0aW9uKVxyXG4gIGNvbnN0IHNwYXduT2Zmc2V0ID0gVmVjdG9yLm11bHRpcGx5KG5vcm1hbGl6ZWREaXIsIG93bmVyLnJhZGl1cyArIHdlYXBvbkRhdGEucmFkaXVzICsgMilcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgaWQ6IGBwcm9qZWN0aWxlXyR7Y3VycmVudFRpbWV9XyR7TWF0aC5yYW5kb20oKX1gLFxyXG4gICAgdHlwZTogJ3Byb2plY3RpbGUnLFxyXG4gICAgd2VhcG9uSWQ6IHdlYXBvbkRhdGEuaWQsXHJcbiAgICBvd25lcklkOiBvd25lci5pZCxcclxuICAgIHBvc2l0aW9uOiBWZWN0b3IuYWRkKG93bmVyLnBvc2l0aW9uLCBzcGF3bk9mZnNldCksXHJcbiAgICB2ZWxvY2l0eTogVmVjdG9yLm11bHRpcGx5KG5vcm1hbGl6ZWREaXIsIHdlYXBvbkRhdGEucHJvamVjdGlsZVNwZWVkIHx8IDIwMCksXHJcbiAgICBhY2NlbGVyYXRpb246IHsgeDogMCwgeTogMCB9LFxyXG4gICAgcmFkaXVzOiB3ZWFwb25EYXRhLnJhZGl1cyxcclxuICAgIG1hc3M6IDEsXHJcbiAgICBoZWFsdGg6IDEsXHJcbiAgICBtYXhIZWFsdGg6IDEsXHJcbiAgICBkYW1hZ2U6IHdlYXBvbkRhdGEuYmFzZURhbWFnZSxcclxuICAgIHJlc3RpdHV0aW9uOiAwLjgsXHJcbiAgICBmcmljdGlvbjogMC4wMixcclxuICAgIGlzU3RhdGljOiBmYWxzZSxcclxuICAgIHNwZWVkOiB3ZWFwb25EYXRhLnByb2plY3RpbGVTcGVlZCB8fCAyMDAsXHJcbiAgICBsaWZldGltZTogd2VhcG9uRGF0YS5saWZldGltZSB8fCAyMDAwLFxyXG4gICAgcGllcmNpbmc6IHdlYXBvbkRhdGEucGllcmNpbmcgfHwgMCxcclxuICAgIGhpdHNSZW1haW5pbmc6IHdlYXBvbkRhdGEucGllcmNpbmcgfHwgMCxcclxuICAgIGJvdW5jZXM6IHdlYXBvbkRhdGEuYm91bmNlcyB8fCAwLFxyXG4gICAgYm91bmNlc1JlbWFpbmluZzogd2VhcG9uRGF0YS5ib3VuY2VzIHx8IDAsXHJcbiAgICBzcGVjaWFsOiB3ZWFwb25EYXRhLnNwZWNpYWwgfHwgW10sXHJcbiAgICBzcGF3blRpbWU6IGN1cnJlbnRUaW1lXHJcbiAgfSBhcyBXZWFwb25Qcm9qZWN0aWxlICYgeyBzcGF3blRpbWU6IG51bWJlciB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYXBvbkF1cmEob3duZXI6IENpcmNsZUVudGl0eSwgd2VhcG9uRGF0YTogYW55LCBjdXJyZW50VGltZTogbnVtYmVyKTogV2VhcG9uQXVyYSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGlkOiBgYXVyYV8ke2N1cnJlbnRUaW1lfV8ke01hdGgucmFuZG9tKCl9YCxcclxuICAgIHR5cGU6ICdhdXJhJyxcclxuICAgIHdlYXBvbklkOiB3ZWFwb25EYXRhLmlkLFxyXG4gICAgb3duZXJJZDogb3duZXIuaWQsXHJcbiAgICBwb3NpdGlvbjogeyAuLi5vd25lci5wb3NpdGlvbiB9LFxyXG4gICAgdmVsb2NpdHk6IHsgeDogMCwgeTogMCB9LFxyXG4gICAgYWNjZWxlcmF0aW9uOiB7IHg6IDAsIHk6IDAgfSxcclxuICAgIHJhZGl1czogd2VhcG9uRGF0YS5hdXJhUmFkaXVzIHx8IHdlYXBvbkRhdGEucmFkaXVzLFxyXG4gICAgbWFzczogMCxcclxuICAgIGhlYWx0aDogMSxcclxuICAgIG1heEhlYWx0aDogMSxcclxuICAgIGRhbWFnZTogd2VhcG9uRGF0YS5iYXNlRGFtYWdlLFxyXG4gICAgcmVzdGl0dXRpb246IDAsXHJcbiAgICBmcmljdGlvbjogMCxcclxuICAgIGlzU3RhdGljOiB0cnVlLFxyXG4gICAgZHVyYXRpb246IHdlYXBvbkRhdGEuYXVyYUR1cmF0aW9uIHx8IDEwMDAsXHJcbiAgICBzcGVjaWFsOiB3ZWFwb25EYXRhLnNwZWNpYWwgfHwgW10sXHJcbiAgICBhZmZlY3RlZEVudGl0aWVzOiBuZXcgU2V0KCksXHJcbiAgICBsaWZldGltZTogd2VhcG9uRGF0YS5hdXJhRHVyYXRpb24gfHwgMTAwMCxcclxuICAgIHNwYXduVGltZTogY3VycmVudFRpbWVcclxuICB9IGFzIFdlYXBvbkF1cmEgJiB7IHNwYXduVGltZTogbnVtYmVyIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVdlYXBvbkNvb2xkb3ducyhlbnRpdHk6IENpcmNsZUVudGl0eSwgY3VycmVudFRpbWU6IG51bWJlcik6IHZvaWQge1xyXG4gIGlmICghZW50aXR5LndlYXBvbkNvb2xkb3ducykgcmV0dXJuXHJcbiAgXHJcbiAgZm9yIChjb25zdCBbd2VhcG9uSWQsIGNvb2xkb3duRW5kXSBvZiBlbnRpdHkud2VhcG9uQ29vbGRvd25zKSB7XHJcbiAgICBpZiAoY3VycmVudFRpbWUgPj0gY29vbGRvd25FbmQpIHtcclxuICAgICAgZW50aXR5LndlYXBvbkNvb2xkb3ducy5kZWxldGUod2VhcG9uSWQpXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVnZW5lcmF0ZUVuZXJneShlbnRpdHk6IENpcmNsZUVudGl0eSwgZHQ6IG51bWJlcik6IHZvaWQge1xyXG4gIGlmIChlbnRpdHkuZW5lcmd5ICE9PSB1bmRlZmluZWQgJiYgZW50aXR5Lm1heEVuZXJneSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICBlbnRpdHkuZW5lcmd5ID0gTWF0aC5taW4oZW50aXR5Lm1heEVuZXJneSwgZW50aXR5LmVuZXJneSArIDIwICogZHQpIC8vIDIwIGVuZXJneS9zZWNcclxuICB9XHJcbn1cclxuXHJcbi8vIEFJIENvbWJhdCBTeXN0ZW1cclxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUFJKGVudGl0eTogQ2lyY2xlRW50aXR5LCB3b3JsZDogUGh5c2ljc1dvcmxkLCBkZWx0YVRpbWU6IG51bWJlciwgd2VhcG9uczogYW55W10pOiB2b2lkIHtcclxuICBpZiAoIWVudGl0eS5pZC5pbmNsdWRlcygnYWknKSAmJiAhZW50aXR5LmlkLmluY2x1ZGVzKCdib3QnKSkgcmV0dXJuXHJcbiAgXHJcbiAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpXHJcbiAgXHJcbiAgLy8gRmluZCBuZWFyZXN0IGVuZW15XHJcbiAgbGV0IG5lYXJlc3RFbmVteTogQ2lyY2xlRW50aXR5IHwgbnVsbCA9IG51bGxcclxuICBsZXQgbmVhcmVzdERpc3RhbmNlID0gSW5maW5pdHlcclxuICBcclxuICBmb3IgKGNvbnN0IFtpZCwgb3RoZXJFbnRpdHldIG9mIHdvcmxkLmVudGl0aWVzKSB7XHJcbiAgICBpZiAob3RoZXJFbnRpdHkgPT09IGVudGl0eSB8fCBvdGhlckVudGl0eS5oZWFsdGggPD0gMCkgY29udGludWVcclxuICAgIGlmIChlbnRpdHkuaWQuaW5jbHVkZXMoJ2JvdCcpICYmIG90aGVyRW50aXR5LmlkLmluY2x1ZGVzKCdib3QnKSkgY29udGludWUgLy8gQm90cyBkb24ndCBmaWdodCBlYWNoIG90aGVyXHJcbiAgICBcclxuICAgIGNvbnN0IGRpc3RhbmNlID0gVmVjdG9yLmRpc3RhbmNlKGVudGl0eS5wb3NpdGlvbiwgb3RoZXJFbnRpdHkucG9zaXRpb24pXHJcbiAgICBpZiAoZGlzdGFuY2UgPCBuZWFyZXN0RGlzdGFuY2UpIHtcclxuICAgICAgbmVhcmVzdERpc3RhbmNlID0gZGlzdGFuY2VcclxuICAgICAgbmVhcmVzdEVuZW15ID0gb3RoZXJFbnRpdHlcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgaWYgKCFuZWFyZXN0RW5lbXkpIHJldHVyblxyXG4gIFxyXG4gIC8vIEFJIEJlaGF2aW9yIGJhc2VkIG9uIGRpc3RhbmNlIGFuZCBoZWFsdGhcclxuICBjb25zdCBoZWFsdGhSYXRpbyA9IGVudGl0eS5oZWFsdGggLyBlbnRpdHkubWF4SGVhbHRoXHJcbiAgY29uc3QgZGlzdGFuY2VUb0VuZW15ID0gbmVhcmVzdERpc3RhbmNlXHJcbiAgXHJcbiAgLy8gTW92ZW1lbnQgQUlcclxuICBpZiAoZGlzdGFuY2VUb0VuZW15ID4gMTAwKSB7XHJcbiAgICAvLyBNb3ZlIHRvd2FyZHMgZW5lbXlcclxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnN1YnRyYWN0KG5lYXJlc3RFbmVteS5wb3NpdGlvbiwgZW50aXR5LnBvc2l0aW9uKSlcclxuICAgIGNvbnN0IG1vdmVGb3JjZSA9IFZlY3Rvci5tdWx0aXBseShkaXJlY3Rpb24sIDIwMCAqIGhlYWx0aFJhdGlvKSAvLyBTbG93ZXIgd2hlbiBodXJ0XHJcbiAgICBhZGRGb3JjZShlbnRpdHksIG1vdmVGb3JjZSlcclxuICB9IGVsc2UgaWYgKGRpc3RhbmNlVG9FbmVteSA8IDUwICYmIGhlYWx0aFJhdGlvIDwgMC4zKSB7XHJcbiAgICAvLyBSZXRyZWF0IHdoZW4gbG93IG9uIGhlYWx0aCBhbmQgdG9vIGNsb3NlXHJcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5zdWJ0cmFjdChlbnRpdHkucG9zaXRpb24sIG5lYXJlc3RFbmVteS5wb3NpdGlvbikpXHJcbiAgICBjb25zdCByZXRyZWF0Rm9yY2UgPSBWZWN0b3IubXVsdGlwbHkoZGlyZWN0aW9uLCAzMDApXHJcbiAgICBhZGRGb3JjZShlbnRpdHksIHJldHJlYXRGb3JjZSlcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gQ2lyY2xlIGFyb3VuZCBlbmVteVxyXG4gICAgY29uc3QgdG9FbmVteSA9IFZlY3Rvci5zdWJ0cmFjdChuZWFyZXN0RW5lbXkucG9zaXRpb24sIGVudGl0eS5wb3NpdGlvbilcclxuICAgIGNvbnN0IHBlcnBlbmRpY3VsYXIgPSB7IHg6IC10b0VuZW15LnksIHk6IHRvRW5lbXkueCB9XHJcbiAgICBjb25zdCBjaXJjbGVEaXJlY3Rpb24gPSBWZWN0b3Iubm9ybWFsaXplKHBlcnBlbmRpY3VsYXIpXHJcbiAgICBjb25zdCBjaXJjbGVGb3JjZSA9IFZlY3Rvci5tdWx0aXBseShjaXJjbGVEaXJlY3Rpb24sIDE1MClcclxuICAgIGFkZEZvcmNlKGVudGl0eSwgY2lyY2xlRm9yY2UpXHJcbiAgfVxyXG4gIFxyXG4gIC8vIENvbWJhdCBBSSAtIHRyeSB0byBhdHRhY2sgZXZlcnkgMS0yIHNlY29uZHNcclxuICBpZiAoIWVudGl0eS5sYXN0QXR0YWNrVGltZSkgZW50aXR5Lmxhc3RBdHRhY2tUaW1lID0gMFxyXG4gIGNvbnN0IHRpbWVTaW5jZUF0dGFjayA9IGN1cnJlbnRUaW1lIC0gZW50aXR5Lmxhc3RBdHRhY2tUaW1lXHJcbiAgY29uc3QgYXR0YWNrQ29vbGRvd24gPSAxMDAwICsgTWF0aC5yYW5kb20oKSAqIDEwMDAgLy8gMS0yIHNlY29uZHNcclxuICBcclxuICBpZiAodGltZVNpbmNlQXR0YWNrID4gYXR0YWNrQ29vbGRvd24gJiYgZGlzdGFuY2VUb0VuZW15IDwgMjAwKSB7XHJcbiAgICAvLyBGaW5kIHdlYXBvbiB0byB1c2VcclxuICAgIGNvbnN0IGF2YWlsYWJsZVdlYXBvbiA9IHdlYXBvbnMuZmluZCh3ID0+IHcuaWQgPT09IGVudGl0eS53ZWFwb25JZClcclxuICAgIGlmIChhdmFpbGFibGVXZWFwb24gJiYgZW50aXR5LmVuZXJneSAmJiBlbnRpdHkuZW5lcmd5ID49IGF2YWlsYWJsZVdlYXBvbi5jb3N0KSB7XHJcbiAgICAgIGNvbnN0IGF0dGFja0RpcmVjdGlvbiA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnN1YnRyYWN0KG5lYXJlc3RFbmVteS5wb3NpdGlvbiwgZW50aXR5LnBvc2l0aW9uKSlcclxuICAgICAgXHJcbiAgICAgIC8vIEFkZCBzb21lIGluYWNjdXJhY3kgdG8gbWFrZSBmaWdodHMgbW9yZSBpbnRlcmVzdGluZ1xyXG4gICAgICBjb25zdCBpbmFjY3VyYWN5ID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMC4zXHJcbiAgICAgIGNvbnN0IGZpbmFsRGlyZWN0aW9uID0ge1xyXG4gICAgICAgIHg6IGF0dGFja0RpcmVjdGlvbi54ICsgaW5hY2N1cmFjeSxcclxuICAgICAgICB5OiBhdHRhY2tEaXJlY3Rpb24ueSArIGluYWNjdXJhY3lcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKGZpcmVXZWFwb24od29ybGQsIGVudGl0eS5pZCwgYXZhaWxhYmxlV2VhcG9uLCBWZWN0b3Iubm9ybWFsaXplKGZpbmFsRGlyZWN0aW9uKSwgY3VycmVudFRpbWUpKSB7XHJcbiAgICAgICAgZW50aXR5Lmxhc3RBdHRhY2tUaW1lID0gY3VycmVudFRpbWVcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiVmVjdG9yIiwiY3JlYXRlIiwieCIsInkiLCJhZGQiLCJhIiwiYiIsInN1YnRyYWN0IiwibXVsdGlwbHkiLCJ2Iiwic2NhbGFyIiwiZG90IiwibWFnbml0dWRlIiwiTWF0aCIsInNxcnQiLCJub3JtYWxpemUiLCJtYWciLCJkaXN0YW5jZSIsImRpZmYiLCJsZXJwIiwidCIsInJvdGF0ZSIsImFuZ2xlIiwiY29zIiwic2luIiwiY3JlYXRlUGh5c2ljc1dvcmxkIiwid2lkdGgiLCJoZWlnaHQiLCJlbnRpdGllcyIsIk1hcCIsImdyYXZpdHkiLCJhaXJGcmljdGlvbiIsInRpbWVBY2N1bXVsYXRvciIsImZpeGVkVGltZVN0ZXAiLCJib3VuZHMiLCJjcmVhdGVDaXJjbGVFbnRpdHkiLCJpZCIsInJhZGl1cyIsInR5cGUiLCJwb3NpdGlvbiIsInZlbG9jaXR5IiwiYWNjZWxlcmF0aW9uIiwibWFzcyIsIlBJIiwiaGVhbHRoIiwibWF4SGVhbHRoIiwiZGFtYWdlIiwicmVzdGl0dXRpb24iLCJmcmljdGlvbiIsImlzU3RhdGljIiwiaW52dWxuZXJhYmxlVW50aWwiLCJjcmVhdGVQcm9qZWN0aWxlIiwiZGlyZWN0aW9uIiwic3BlZWQiLCJvd25lcklkIiwibGlmZXRpbWUiLCJwaWVyY2luZyIsImhpdHNSZW1haW5pbmciLCJkZXRlY3RDb2xsaXNpb24iLCJtaW5EaXN0YW5jZSIsIm5vcm1hbCIsInBlbmV0cmF0aW9uIiwicmVsYXRpdmVWZWxvY2l0eSIsImVudGl0eUEiLCJlbnRpdHlCIiwicmVzb2x2ZUNvbGxpc2lvbiIsImNvbGxpc2lvbiIsIndvcmxkIiwiY29ycmVjdGlvblBlcmNlbnQiLCJjb3JyZWN0aW9uIiwidG90YWxNYXNzIiwiYmFzZURhbWFnZSIsIm1heCIsIm1vbWVudHVtRGFtYWdlIiwibWluIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwicmVsYXRpdmVWZWwiLCJ2ZWxBbG9uZ05vcm1hbCIsImltcHVsc2VTY2FsYXIiLCJpbXB1bHNlIiwicmFuZG9tQm9vc3QiLCJyYW5kb20iLCJwcm9qZWN0aWxlIiwidGFyZ2V0IiwicHJvamVjdGlsZURhbWFnZSIsImlzQ3JpdGljYWxIaXQiLCJ3ZWFwb25JZCIsInNwYXduV2VhcG9uUGlja3VwIiwidW5kZWZpbmVkIiwiZGVsZXRlIiwiYXBwbHlDaGFpbktub2NrYmFjayIsInB1c2hpbmdFbnRpdHkiLCJwdXNoZWRFbnRpdHkiLCJjaGFpblJhZGl1cyIsImVudGl0eSIsImtub2NrYmFja0RpcmVjdGlvbiIsImtub2NrYmFja0ZvcmNlIiwicGlja3VwIiwidG9TdHJpbmciLCJzdWJzdHIiLCJzZXQiLCJhcHBseUZyaWN0aW9uIiwiaW50ZWdyYXRlIiwiZHQiLCJoYW5kbGVCb3VuZGFyeUNvbGxpc2lvbiIsImJvdW5jZUZhY3RvciIsInNpbXVsYXRlU3RlcCIsImRlbHRhVGltZSIsInNwYXduVGltZSIsInVwZGF0ZVdlYXBvbkNvb2xkb3ducyIsInJlZ2VuZXJhdGVFbmVyZ3kiLCJ3ZWFwb25zIiwidXBkYXRlQUkiLCJBcnJheSIsImZyb20iLCJ2YWx1ZXMiLCJpIiwibGVuZ3RoIiwiaiIsImFkZEZvcmNlIiwiZm9yY2UiLCJzZXRWZWxvY2l0eSIsInRlbGVwb3J0IiwiZmlyZVdlYXBvbiIsImVudGl0eUlkIiwid2VhcG9uRGF0YSIsInRhcmdldERpcmVjdGlvbiIsImdldCIsImNvb2xkb3duRW5kIiwid2VhcG9uQ29vbGRvd25zIiwiZW5lcmd5IiwiY29zdCIsImNvb2xkb3duTXMiLCJjcmVhdGVXZWFwb25Qcm9qZWN0aWxlIiwiYXVyYSIsImNyZWF0ZVdlYXBvbkF1cmEiLCJvd25lciIsIm5vcm1hbGl6ZWREaXIiLCJzcGF3bk9mZnNldCIsInByb2plY3RpbGVTcGVlZCIsImJvdW5jZXMiLCJib3VuY2VzUmVtYWluaW5nIiwic3BlY2lhbCIsImF1cmFSYWRpdXMiLCJkdXJhdGlvbiIsImF1cmFEdXJhdGlvbiIsImFmZmVjdGVkRW50aXRpZXMiLCJTZXQiLCJtYXhFbmVyZ3kiLCJpbmNsdWRlcyIsIm5lYXJlc3RFbmVteSIsIm5lYXJlc3REaXN0YW5jZSIsIkluZmluaXR5Iiwib3RoZXJFbnRpdHkiLCJoZWFsdGhSYXRpbyIsImRpc3RhbmNlVG9FbmVteSIsIm1vdmVGb3JjZSIsInJldHJlYXRGb3JjZSIsInRvRW5lbXkiLCJwZXJwZW5kaWN1bGFyIiwiY2lyY2xlRGlyZWN0aW9uIiwiY2lyY2xlRm9yY2UiLCJsYXN0QXR0YWNrVGltZSIsInRpbWVTaW5jZUF0dGFjayIsImF0dGFja0Nvb2xkb3duIiwiYXZhaWxhYmxlV2VhcG9uIiwiZmluZCIsInciLCJhdHRhY2tEaXJlY3Rpb24iLCJpbmFjY3VyYWN5IiwiZmluYWxEaXJlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/physics.ts\n"));

/***/ })

});