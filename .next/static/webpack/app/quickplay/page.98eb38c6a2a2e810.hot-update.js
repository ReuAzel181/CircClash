"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/quickplay/page",{

/***/ "(app-pages-browser)/./lib/physics.ts":
/*!************************!*\
  !*** ./lib/physics.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector: function() { return /* binding */ Vector; },\n/* harmony export */   addForce: function() { return /* binding */ addForce; },\n/* harmony export */   applyChainKnockback: function() { return /* binding */ applyChainKnockback; },\n/* harmony export */   applyFriction: function() { return /* binding */ applyFriction; },\n/* harmony export */   createCircleEntity: function() { return /* binding */ createCircleEntity; },\n/* harmony export */   createPhysicsWorld: function() { return /* binding */ createPhysicsWorld; },\n/* harmony export */   createProjectile: function() { return /* binding */ createProjectile; },\n/* harmony export */   detectCollision: function() { return /* binding */ detectCollision; },\n/* harmony export */   fireWeapon: function() { return /* binding */ fireWeapon; },\n/* harmony export */   handleBoundaryCollision: function() { return /* binding */ handleBoundaryCollision; },\n/* harmony export */   integrate: function() { return /* binding */ integrate; },\n/* harmony export */   regenerateEnergy: function() { return /* binding */ regenerateEnergy; },\n/* harmony export */   resolveCollision: function() { return /* binding */ resolveCollision; },\n/* harmony export */   setVelocity: function() { return /* binding */ setVelocity; },\n/* harmony export */   simulateStep: function() { return /* binding */ simulateStep; },\n/* harmony export */   teleport: function() { return /* binding */ teleport; },\n/* harmony export */   updateAI: function() { return /* binding */ updateAI; },\n/* harmony export */   updateWeaponCooldowns: function() { return /* binding */ updateWeaponCooldowns; }\n/* harmony export */ });\n// Core physics types and functions for deterministic circle-based gameplay\n// Vector math utilities\nconst Vector = {\n    create: function() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        return {\n            x,\n            y\n        };\n    },\n    add: (a, b)=>({\n            x: a.x + b.x,\n            y: a.y + b.y\n        }),\n    subtract: (a, b)=>({\n            x: a.x - b.x,\n            y: a.y - b.y\n        }),\n    multiply: (v, scalar)=>({\n            x: v.x * scalar,\n            y: v.y * scalar\n        }),\n    dot: (a, b)=>a.x * b.x + a.y * b.y,\n    magnitude: (v)=>Math.sqrt(v.x * v.x + v.y * v.y),\n    normalize: (v)=>{\n        const mag = Vector.magnitude(v);\n        if (mag === 0) return Vector.create();\n        return Vector.multiply(v, 1 / mag);\n    },\n    distance: (a, b)=>{\n        const diff = Vector.subtract(a, b);\n        return Vector.magnitude(diff);\n    },\n    lerp: (a, b, t)=>({\n            x: a.x + (b.x - a.x) * t,\n            y: a.y + (b.y - a.y) * t\n        }),\n    rotate: (v, angle)=>{\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        return {\n            x: v.x * cos - v.y * sin,\n            y: v.x * sin + v.y * cos\n        };\n    }\n};\n// Physics simulation functions\nfunction createPhysicsWorld(width, height) {\n    return {\n        entities: new Map(),\n        gravity: Vector.create(0, 0),\n        airFriction: 0.99,\n        timeAccumulator: 0,\n        fixedTimeStep: 1 / 60,\n        bounds: {\n            width,\n            height\n        }\n    };\n}\nfunction createCircleEntity(id, x, y, radius) {\n    let type = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"player\";\n    return {\n        id,\n        position: Vector.create(x, y),\n        velocity: Vector.create(),\n        acceleration: Vector.create(),\n        radius,\n        mass: Math.PI * radius * radius,\n        health: 100,\n        maxHealth: 100,\n        damage: 20,\n        restitution: 1.0,\n        friction: 1.0,\n        isStatic: false,\n        type,\n        invulnerableUntil: 0\n    };\n}\nfunction createProjectile(id, x, y, direction, speed, ownerId) {\n    let lifetime = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 3000, characterType = arguments.length > 7 ? arguments[7] : void 0;\n    const velocity = Vector.multiply(Vector.normalize(direction), speed);\n    return {\n        id,\n        position: Vector.create(x, y),\n        velocity,\n        acceleration: Vector.create(),\n        radius: 5,\n        mass: 1,\n        health: 1,\n        maxHealth: 1,\n        damage: 10,\n        restitution: 0.2,\n        friction: 1,\n        isStatic: false,\n        type: \"projectile\",\n        ownerId,\n        speed,\n        lifetime,\n        piercing: 0,\n        hitsRemaining: 1,\n        characterType\n    };\n}\n// Collision detection\nfunction detectCollision(a, b) {\n    const distance = Vector.distance(a.position, b.position);\n    const minDistance = a.radius + b.radius;\n    if (distance >= minDistance) {\n        return null // No collision\n        ;\n    }\n    const normal = Vector.normalize(Vector.subtract(b.position, a.position));\n    const penetration = minDistance - distance;\n    const relativeVelocity = Vector.magnitude(Vector.subtract(a.velocity, b.velocity));\n    return {\n        entityA: a,\n        entityB: b,\n        normal,\n        penetration,\n        relativeVelocity\n    };\n}\n// Collision response with momentum-based damage\nfunction resolveCollision(collision, world) {\n    const { entityA, entityB, normal, penetration, relativeVelocity } = collision;\n    // Skip if either entity is static and the other is a projectile\n    if ((entityA.isStatic || entityB.isStatic) && (entityA.type === \"projectile\" || entityB.type === \"projectile\")) {\n        return;\n    }\n    // Positional correction to prevent overlap\n    const correctionPercent = 0.8;\n    const correction = Vector.multiply(normal, penetration * correctionPercent);\n    if (!entityA.isStatic && !entityB.isStatic) {\n        const totalMass = entityA.mass + entityB.mass;\n        entityA.position = Vector.subtract(entityA.position, Vector.multiply(correction, entityB.mass / totalMass));\n        entityB.position = Vector.add(entityB.position, Vector.multiply(correction, entityA.mass / totalMass));\n    } else if (!entityA.isStatic) {\n        entityA.position = Vector.subtract(entityA.position, correction);\n    } else if (!entityB.isStatic) {\n        entityB.position = Vector.add(entityB.position, correction);\n    }\n    // Calculate momentum-based damage (reduced for longer battles)\n    const baseDamage = Math.max(entityA.damage, entityB.damage);\n    const momentumDamage = baseDamage * 0.3 * (1 + Math.min(relativeVelocity / 600, 1) // Reduced by 70%\n    );\n    // Apply damage with invulnerability frames\n    const currentTime = Date.now();\n    if (entityA.type !== \"projectile\" && entityB.type !== \"pickup\" && entityA.invulnerableUntil < currentTime) {\n        entityA.health = Math.max(0, entityA.health - momentumDamage);\n        entityA.invulnerableUntil = currentTime + 500 // 500ms immunity\n        ;\n    }\n    if (entityB.type !== \"projectile\" && entityA.type !== \"pickup\" && entityB.invulnerableUntil < currentTime) {\n        entityB.health = Math.max(0, entityB.health - momentumDamage);\n        entityB.invulnerableUntil = currentTime + 500;\n    }\n    // Elastic collision response - but don't affect projectile velocities\n    if (!entityA.isStatic && !entityB.isStatic && entityA.type !== \"projectile\" && entityB.type !== \"projectile\") {\n        const relativeVel = Vector.subtract(entityA.velocity, entityB.velocity);\n        const velAlongNormal = Vector.dot(relativeVel, normal);\n        if (velAlongNormal > 0) return; // Objects separating\n        const restitution = Math.max(entityA.restitution, entityB.restitution) * 1.05 // Slightly gain energy to maintain movement\n        ;\n        const impulseScalar = -(1 + restitution) * velAlongNormal / (1 / entityA.mass + 1 / entityB.mass);\n        const impulse = Vector.multiply(normal, impulseScalar);\n        // Small random variation for natural movement\n        const randomBoost = Vector.create((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);\n        entityA.velocity = Vector.add(entityA.velocity, Vector.add(Vector.multiply(impulse, 1 / entityA.mass), randomBoost));\n        entityB.velocity = Vector.subtract(entityB.velocity, Vector.add(Vector.multiply(impulse, 1 / entityB.mass), randomBoost));\n    }\n    // Handle projectile hits\n    if (entityA.type === \"projectile\" || entityB.type === \"projectile\") {\n        const projectile = entityA.type === \"projectile\" ? entityA : entityB;\n        const target = entityA.type === \"projectile\" ? entityB : entityA;\n        // Prevent friendly fire - projectiles don't hurt their owner\n        if (projectile.ownerId === target.id) {\n            return; // Skip damage if projectile hits its owner\n        }\n        // Apply damage to target\n        if (target.type === \"player\" && target.health > 0) {\n            const projectileDamage = projectile.damage || 10 // Reduced default from 25 to 10\n            ;\n            target.health = Math.max(0, target.health - projectileDamage);\n            // Check for critical hit (high velocity impact)\n            const isCriticalHit = relativeVelocity > 400;\n            if (isCriticalHit && target.weaponId && target.type === \"player\") {\n                // Weapon swap on critical hit - drop weapon as pickup\n                spawnWeaponPickup(world, target.position, target.weaponId);\n                target.weaponId = undefined;\n            }\n        }\n        // Remove projectile or reduce piercing\n        if (projectile.hitsRemaining <= 1) {\n            world.entities.delete(projectile.id);\n        } else {\n            projectile.hitsRemaining--;\n        }\n    }\n}\n// Chain knockback - when moving circle forces another into a third\nfunction applyChainKnockback(world, collision) {\n    const { entityA, entityB } = collision;\n    const pushingEntity = Vector.magnitude(entityA.velocity) > Vector.magnitude(entityB.velocity) ? entityA : entityB;\n    const pushedEntity = pushingEntity === entityA ? entityB : entityA;\n    // Find entities that might be hit by the pushed entity\n    const chainRadius = pushedEntity.radius + 50 // Detection range\n    ;\n    for (const [id, entity] of world.entities){\n        if (entity.id === pushedEntity.id || entity.id === pushingEntity.id) continue;\n        const distance = Vector.distance(pushedEntity.position, entity.position);\n        if (distance <= chainRadius) {\n            // Apply reduced knockback\n            const knockbackDirection = Vector.normalize(Vector.subtract(entity.position, pushedEntity.position));\n            const knockbackForce = Vector.magnitude(pushedEntity.velocity) * 0.3 // Reduced force\n            ;\n            if (!entity.isStatic) {\n                entity.velocity = Vector.add(entity.velocity, Vector.multiply(knockbackDirection, knockbackForce));\n            }\n        }\n    }\n}\nfunction spawnWeaponPickup(world, position, weaponId) {\n    const pickup = createCircleEntity(\"pickup_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)), position.x, position.y, 15, \"pickup\");\n    pickup.weaponId = weaponId;\n    pickup.isStatic = true;\n    pickup.lifetime = 15000 // 15 seconds\n    ;\n    world.entities.set(pickup.id, pickup);\n}\n// Apply friction to all entities\nfunction applyFriction(world) {\n    for (const [id, entity] of world.entities){\n        if (!entity.isStatic && entity.type !== \"projectile\") {\n            // No friction for players - they should maintain constant movement like bouncing balls\n            if (entity.type === \"player\") {\n                // Maintain constant speed for bouncing ball physics\n                const currentSpeed = Vector.magnitude(entity.velocity);\n                const targetSpeed = 250 // Constant bouncing speed\n                ;\n                if (currentSpeed > 5) {\n                    const direction = Vector.normalize(entity.velocity);\n                    entity.velocity = Vector.multiply(direction, targetSpeed);\n                }\n            } else {\n                // Apply normal friction to other entities\n                entity.velocity = Vector.multiply(entity.velocity, entity.friction);\n                // Stop very slow movement to prevent jitter\n                if (Vector.magnitude(entity.velocity) < 0.1) {\n                    entity.velocity = Vector.create();\n                }\n            }\n        }\n    }\n}\n// Integrate position and velocity using Verlet integration\nfunction integrate(entity, dt) {\n    if (entity.isStatic) return;\n    // Apply gravity\n    entity.velocity = Vector.add(entity.velocity, Vector.multiply(entity.acceleration, dt));\n    // Update position\n    entity.position = Vector.add(entity.position, Vector.multiply(entity.velocity, dt));\n    // Reset acceleration for next frame\n    entity.acceleration = Vector.create();\n}\n// Boundary collision\nfunction handleBoundaryCollision(entity, bounds) {\n    if (entity.isStatic || entity.type === \"projectile\") return; // Skip projectiles - handled separately\n    const bounceFactor = entity.restitution * 1.0 // Perfect bounce to maintain constant movement\n    ;\n    // Left boundary\n    if (entity.position.x - entity.radius < 0) {\n        entity.position.x = entity.radius;\n        entity.velocity.x = -entity.velocity.x * bounceFactor;\n        // Small random component for variety but maintain overall speed\n        entity.velocity.y += (Math.random() - 0.5) * 20;\n    }\n    // Right boundary\n    if (entity.position.x + entity.radius > bounds.width) {\n        entity.position.x = bounds.width - entity.radius;\n        entity.velocity.x = -entity.velocity.x * bounceFactor;\n        // Small random component for variety but maintain overall speed\n        entity.velocity.y += (Math.random() - 0.5) * 20;\n    }\n    // Top boundary\n    if (entity.position.y - entity.radius < 0) {\n        entity.position.y = entity.radius;\n        entity.velocity.y = -entity.velocity.y * bounceFactor;\n        // Small random component for variety but maintain overall speed\n        entity.velocity.x += (Math.random() - 0.5) * 20;\n    }\n    // Bottom boundary\n    if (entity.position.y + entity.radius > bounds.height) {\n        entity.position.y = bounds.height - entity.radius;\n        entity.velocity.y = -entity.velocity.y * bounceFactor;\n        // Small random component for variety but maintain overall speed\n        entity.velocity.x += (Math.random() - 0.5) * 20;\n    }\n}\n// Main physics simulation step\nfunction simulateStep(world, deltaTime) {\n    world.timeAccumulator += deltaTime;\n    // Fixed timestep with accumulator pattern for determinism\n    while(world.timeAccumulator >= world.fixedTimeStep){\n        const currentTime = Date.now();\n        // Remove expired entities\n        for (const [id, entity] of world.entities){\n            if (entity.lifetime && currentTime > (entity.lifetime + entity.spawnTime || 0)) {\n                world.entities.delete(id);\n                continue;\n            }\n            // Remove dead entities\n            if (entity.health <= 0) {\n                world.entities.delete(id);\n                continue;\n            }\n        }\n        // Update weapon systems and energy\n        for (const [id, entity] of world.entities){\n            updateWeaponCooldowns(entity, currentTime);\n            regenerateEnergy(entity, world.fixedTimeStep);\n        }\n        // Update AI (will be called with weapons from outside)\n        if (world.weapons) {\n            for (const [id, entity] of world.entities){\n                if (entity.health > 0) {\n                    updateAI(entity, world, world.fixedTimeStep, world.weapons);\n                }\n            }\n        }\n        // Integration step - handle projectiles separately\n        for (const [id, entity] of world.entities){\n            if (entity.type === \"projectile\") {\n                // Projectiles only update position, no physics interactions\n                entity.position.x += entity.velocity.x * world.fixedTimeStep;\n                entity.position.y += entity.velocity.y * world.fixedTimeStep;\n                // Check boundaries for projectiles (remove when hitting walls)\n                if (entity.position.x - entity.radius <= 0 || entity.position.x + entity.radius >= world.bounds.width || entity.position.y - entity.radius <= 0 || entity.position.y + entity.radius >= world.bounds.height) {\n                    entity.health = 0 // Mark for removal\n                    ;\n                }\n            } else {\n                // Normal physics for non-projectiles\n                integrate(entity, world.fixedTimeStep);\n                handleBoundaryCollision(entity, world.bounds);\n            }\n        }\n        // Collision detection and response\n        const entities = Array.from(world.entities.values());\n        for(let i = 0; i < entities.length; i++){\n            for(let j = i + 1; j < entities.length; j++){\n                const entityA = entities[i];\n                const entityB = entities[j];\n                // Skip projectile-to-projectile collisions\n                if (entityA.type === \"projectile\" && entityB.type === \"projectile\") {\n                    continue;\n                }\n                const collision = detectCollision(entityA, entityB);\n                if (collision) {\n                    resolveCollision(collision, world);\n                    // Only apply chain knockback for non-projectile entities\n                    if (entityA.type !== \"projectile\" && entityB.type !== \"projectile\") {\n                        applyChainKnockback(world, collision);\n                    }\n                }\n            }\n        }\n        // Apply friction\n        applyFriction(world);\n        world.timeAccumulator -= world.fixedTimeStep;\n    }\n}\n// Utility functions for external use\nfunction addForce(entity, force) {\n    if (!entity.isStatic) {\n        entity.acceleration = Vector.add(entity.acceleration, Vector.multiply(force, 1 / entity.mass));\n    }\n}\nfunction setVelocity(entity, velocity) {\n    if (!entity.isStatic) {\n        entity.velocity = velocity;\n    }\n}\nfunction teleport(entity, position) {\n    entity.position = position;\n}\n// Weapon system integration\nfunction fireWeapon(world, entityId, weaponData, targetDirection, currentTime) {\n    var _entity_weaponCooldowns;\n    const entity = world.entities.get(entityId);\n    if (!entity) return false;\n    // Check cooldown and energy\n    const cooldownEnd = ((_entity_weaponCooldowns = entity.weaponCooldowns) === null || _entity_weaponCooldowns === void 0 ? void 0 : _entity_weaponCooldowns.get(weaponData.id)) || 0;\n    if (currentTime < cooldownEnd) return false;\n    if ((entity.energy || 0) < weaponData.cost) return false;\n    // Update entity cooldown and energy\n    if (!entity.weaponCooldowns) entity.weaponCooldowns = new Map();\n    entity.weaponCooldowns.set(weaponData.id, currentTime + weaponData.cooldownMs);\n    entity.energy = (entity.energy || 0) - weaponData.cost;\n    // Create weapon effect\n    if (weaponData.type === \"projectile\") {\n        const projectile = createWeaponProjectile(entity, weaponData, targetDirection, currentTime);\n        world.entities.set(projectile.id, projectile);\n    } else if (weaponData.type === \"aura\") {\n        const aura = createWeaponAura(entity, weaponData, currentTime);\n        world.entities.set(aura.id, aura);\n    }\n    return true;\n}\nfunction createWeaponProjectile(owner, weaponData, direction, currentTime) {\n    const normalizedDir = Vector.normalize(direction);\n    const spawnOffset = Vector.multiply(normalizedDir, owner.radius + weaponData.radius + 2);\n    return {\n        id: \"projectile_\".concat(currentTime, \"_\").concat(Math.random()),\n        type: \"projectile\",\n        weaponId: weaponData.id,\n        ownerId: owner.id,\n        position: Vector.add(owner.position, spawnOffset),\n        velocity: Vector.multiply(normalizedDir, weaponData.projectileSpeed || 200),\n        acceleration: {\n            x: 0,\n            y: 0\n        },\n        radius: weaponData.radius,\n        mass: 1,\n        health: 1,\n        maxHealth: 1,\n        damage: weaponData.baseDamage,\n        restitution: 0.8,\n        friction: 0.02,\n        isStatic: false,\n        speed: weaponData.projectileSpeed || 200,\n        lifetime: weaponData.lifetime || 2000,\n        piercing: weaponData.piercing || 0,\n        hitsRemaining: weaponData.piercing || 0,\n        bounces: weaponData.bounces || 0,\n        bouncesRemaining: weaponData.bounces || 0,\n        special: weaponData.special || [],\n        spawnTime: currentTime\n    };\n}\nfunction createWeaponAura(owner, weaponData, currentTime) {\n    return {\n        id: \"aura_\".concat(currentTime, \"_\").concat(Math.random()),\n        type: \"aura\",\n        weaponId: weaponData.id,\n        ownerId: owner.id,\n        position: {\n            ...owner.position\n        },\n        velocity: {\n            x: 0,\n            y: 0\n        },\n        acceleration: {\n            x: 0,\n            y: 0\n        },\n        radius: weaponData.auraRadius || weaponData.radius,\n        mass: 0,\n        health: 1,\n        maxHealth: 1,\n        damage: weaponData.baseDamage,\n        restitution: 0,\n        friction: 0,\n        isStatic: true,\n        duration: weaponData.auraDuration || 1000,\n        special: weaponData.special || [],\n        affectedEntities: new Set(),\n        lifetime: weaponData.auraDuration || 1000,\n        spawnTime: currentTime\n    };\n}\nfunction updateWeaponCooldowns(entity, currentTime) {\n    if (!entity.weaponCooldowns) return;\n    for (const [weaponId, cooldownEnd] of entity.weaponCooldowns){\n        if (currentTime >= cooldownEnd) {\n            entity.weaponCooldowns.delete(weaponId);\n        }\n    }\n}\nfunction regenerateEnergy(entity, dt) {\n    if (entity.energy !== undefined && entity.maxEnergy !== undefined) {\n        entity.energy = Math.min(entity.maxEnergy, entity.energy + 20 * dt) // 20 energy/sec\n        ;\n    }\n}\n// AI Combat System\nfunction updateAI(entity, world, deltaTime, weapons) {\n    if (!entity.id.includes(\"ai\") && !entity.id.includes(\"bot\")) return;\n    const currentTime = Date.now();\n    // Find nearest enemy\n    let nearestEnemy = null;\n    let nearestDistance = Infinity;\n    for (const [id, otherEntity] of world.entities){\n        if (otherEntity === entity || otherEntity.health <= 0) continue;\n        if (entity.id.includes(\"bot\") && otherEntity.id.includes(\"bot\")) continue; // Bots don't fight each other\n        const distance = Vector.distance(entity.position, otherEntity.position);\n        if (distance < nearestDistance) {\n            nearestDistance = distance;\n            nearestEnemy = otherEntity;\n        }\n    }\n    if (!nearestEnemy) return;\n    // AI Behavior based on distance and health\n    const healthRatio = entity.health / entity.maxHealth;\n    const distanceToEnemy = nearestDistance;\n    // Movement AI\n    if (distanceToEnemy > 100) {\n        // Move towards enemy\n        const direction = Vector.normalize(Vector.subtract(nearestEnemy.position, entity.position));\n        const moveForce = Vector.multiply(direction, 200 * healthRatio) // Slower when hurt\n        ;\n        addForce(entity, moveForce);\n    } else if (distanceToEnemy < 50 && healthRatio < 0.3) {\n        // Retreat when low on health and too close\n        const direction = Vector.normalize(Vector.subtract(entity.position, nearestEnemy.position));\n        const retreatForce = Vector.multiply(direction, 300);\n        addForce(entity, retreatForce);\n    } else {\n        // Circle around enemy\n        const toEnemy = Vector.subtract(nearestEnemy.position, entity.position);\n        const perpendicular = {\n            x: -toEnemy.y,\n            y: toEnemy.x\n        };\n        const circleDirection = Vector.normalize(perpendicular);\n        const circleForce = Vector.multiply(circleDirection, 150);\n        addForce(entity, circleForce);\n    }\n    // Combat AI - try to attack every 1-2 seconds\n    if (!entity.lastAttackTime) entity.lastAttackTime = 0;\n    const timeSinceAttack = currentTime - entity.lastAttackTime;\n    const attackCooldown = 1000 + Math.random() * 1000 // 1-2 seconds\n    ;\n    if (timeSinceAttack > attackCooldown && distanceToEnemy < 200) {\n        // Find weapon to use\n        const availableWeapon = weapons.find((w)=>w.id === entity.weaponId);\n        if (availableWeapon && entity.energy && entity.energy >= availableWeapon.cost) {\n            const attackDirection = Vector.normalize(Vector.subtract(nearestEnemy.position, entity.position));\n            // Add some inaccuracy to make fights more interesting\n            const inaccuracy = (Math.random() - 0.5) * 0.3;\n            const finalDirection = {\n                x: attackDirection.x + inaccuracy,\n                y: attackDirection.y + inaccuracy\n            };\n            if (fireWeapon(world, entity.id, availableWeapon, Vector.normalize(finalDirection), currentTime)) {\n                entity.lastAttackTime = currentTime;\n            }\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9waHlzaWNzLnRzPzU4ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29yZSBwaHlzaWNzIHR5cGVzIGFuZCBmdW5jdGlvbnMgZm9yIGRldGVybWluaXN0aWMgY2lyY2xlLWJhc2VkIGdhbWVwbGF5XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvciB7XHJcbiAgeDogbnVtYmVyXHJcbiAgeTogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2lyY2xlRW50aXR5IHtcclxuICBpZDogc3RyaW5nXHJcbiAgcG9zaXRpb246IFZlY3RvclxyXG4gIHZlbG9jaXR5OiBWZWN0b3JcclxuICBhY2NlbGVyYXRpb246IFZlY3RvclxyXG4gIHJhZGl1czogbnVtYmVyXHJcbiAgbWFzczogbnVtYmVyXHJcbiAgaGVhbHRoOiBudW1iZXJcclxuICBtYXhIZWFsdGg6IG51bWJlclxyXG4gIGRhbWFnZTogbnVtYmVyXHJcbiAgd2VhcG9uSWQ/OiBzdHJpbmdcclxuICByZXN0aXR1dGlvbjogbnVtYmVyIC8vIEJvdW5jZSBjb2VmZmljaWVudCAoMC0xKVxyXG4gIGZyaWN0aW9uOiBudW1iZXIgLy8gTW92ZW1lbnQgZnJpY3Rpb24gKDAtMSlcclxuICBpc1N0YXRpYzogYm9vbGVhbiAvLyBJbW1vdmFibGUgb2JqZWN0c1xyXG4gIHR5cGU6ICdwbGF5ZXInIHwgJ3Byb2plY3RpbGUnIHwgJ3BpY2t1cCcgfCAnaGF6YXJkJyB8ICdhdXJhJ1xyXG4gIG93bmVySWQ/OiBzdHJpbmcgLy8gRm9yIHByb2plY3RpbGVzXHJcbiAgbGlmZXRpbWU/OiBudW1iZXIgLy8gRm9yIHRlbXBvcmFyeSBlbnRpdGllc1xyXG4gIGludnVsbmVyYWJsZVVudGlsPzogbnVtYmVyIC8vIEltbXVuaXR5IGZyYW1lc1xyXG4gIC8vIFdlYXBvbiBzeXN0ZW1cclxuICBlcXVpcHBlZFdlYXBvbj86IHN0cmluZ1xyXG4gIHdlYXBvbkNvb2xkb3ducz86IE1hcDxzdHJpbmcsIG51bWJlcj5cclxuICBlbmVyZ3k/OiBudW1iZXJcclxuICBtYXhFbmVyZ3k/OiBudW1iZXJcclxuICBzcGVjaWFsPzogc3RyaW5nW10gLy8gU3BlY2lhbCBiZWhhdmlvciBmbGFnc1xyXG4gIC8vIEFJIHN5c3RlbVxyXG4gIGxhc3RBdHRhY2tUaW1lPzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2VhcG9uUHJvamVjdGlsZSBleHRlbmRzIENpcmNsZUVudGl0eSB7XHJcbiAgdHlwZTogJ3Byb2plY3RpbGUnXHJcbiAgd2VhcG9uSWQ6IHN0cmluZ1xyXG4gIHNwZWVkOiBudW1iZXJcclxuICBsaWZldGltZTogbnVtYmVyXHJcbiAgcGllcmNpbmc6IG51bWJlciAvLyBIb3cgbWFueSBlbnRpdGllcyBpdCBjYW4gaGl0XHJcbiAgaGl0c1JlbWFpbmluZzogbnVtYmVyXHJcbiAgYm91bmNlczogbnVtYmVyXHJcbiAgYm91bmNlc1JlbWFpbmluZzogbnVtYmVyXHJcbiAgc3BlY2lhbDogc3RyaW5nW11cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXZWFwb25BdXJhIGV4dGVuZHMgQ2lyY2xlRW50aXR5IHtcclxuICB0eXBlOiAnYXVyYSdcclxuICB3ZWFwb25JZDogc3RyaW5nXHJcbiAgZHVyYXRpb246IG51bWJlclxyXG4gIHNwZWNpYWw6IHN0cmluZ1tdXHJcbiAgYWZmZWN0ZWRFbnRpdGllczogU2V0PHN0cmluZz4gLy8gVHJhY2sgd2hpY2ggZW50aXRpZXMgYXJlIGluIHJhbmdlXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdGlsZSBleHRlbmRzIENpcmNsZUVudGl0eSB7XHJcbiAgdHlwZTogJ3Byb2plY3RpbGUnXHJcbiAgc3BlZWQ6IG51bWJlclxyXG4gIGxpZmV0aW1lOiBudW1iZXJcclxuICBwaWVyY2luZzogbnVtYmVyIC8vIEhvdyBtYW55IGVudGl0aWVzIGl0IGNhbiBoaXRcclxuICBoaXRzUmVtYWluaW5nOiBudW1iZXJcclxuICBjaGFyYWN0ZXJUeXBlPzogc3RyaW5nIC8vIEZvciB2aXN1YWwgc3R5bGluZ1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENvbGxpc2lvbiB7XHJcbiAgZW50aXR5QTogQ2lyY2xlRW50aXR5XHJcbiAgZW50aXR5QjogQ2lyY2xlRW50aXR5XHJcbiAgbm9ybWFsOiBWZWN0b3JcclxuICBwZW5ldHJhdGlvbjogbnVtYmVyXHJcbiAgcmVsYXRpdmVWZWxvY2l0eTogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGh5c2ljc1dvcmxkIHtcclxuICBlbnRpdGllczogTWFwPHN0cmluZywgQ2lyY2xlRW50aXR5PlxyXG4gIGdyYXZpdHk6IFZlY3RvclxyXG4gIGFpckZyaWN0aW9uOiBudW1iZXJcclxuICB0aW1lQWNjdW11bGF0b3I6IG51bWJlclxyXG4gIGZpeGVkVGltZVN0ZXA6IG51bWJlciAvLyAxLzYwIGZvciA2MGZwcyBwaHlzaWNzXHJcbiAgYm91bmRzOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH1cclxufVxyXG5cclxuLy8gVmVjdG9yIG1hdGggdXRpbGl0aWVzXHJcbmV4cG9ydCBjb25zdCBWZWN0b3IgPSB7XHJcbiAgY3JlYXRlOiAoeDogbnVtYmVyID0gMCwgeTogbnVtYmVyID0gMCk6IFZlY3RvciA9PiAoeyB4LCB5IH0pLFxyXG4gIFxyXG4gIGFkZDogKGE6IFZlY3RvciwgYjogVmVjdG9yKTogVmVjdG9yID0+ICh7XHJcbiAgICB4OiBhLnggKyBiLngsXHJcbiAgICB5OiBhLnkgKyBiLnlcclxuICB9KSxcclxuICBcclxuICBzdWJ0cmFjdDogKGE6IFZlY3RvciwgYjogVmVjdG9yKTogVmVjdG9yID0+ICh7XHJcbiAgICB4OiBhLnggLSBiLngsXHJcbiAgICB5OiBhLnkgLSBiLnlcclxuICB9KSxcclxuICBcclxuICBtdWx0aXBseTogKHY6IFZlY3Rvciwgc2NhbGFyOiBudW1iZXIpOiBWZWN0b3IgPT4gKHtcclxuICAgIHg6IHYueCAqIHNjYWxhcixcclxuICAgIHk6IHYueSAqIHNjYWxhclxyXG4gIH0pLFxyXG4gIFxyXG4gIGRvdDogKGE6IFZlY3RvciwgYjogVmVjdG9yKTogbnVtYmVyID0+IGEueCAqIGIueCArIGEueSAqIGIueSxcclxuICBcclxuICBtYWduaXR1ZGU6ICh2OiBWZWN0b3IpOiBudW1iZXIgPT4gTWF0aC5zcXJ0KHYueCAqIHYueCArIHYueSAqIHYueSksXHJcbiAgXHJcbiAgbm9ybWFsaXplOiAodjogVmVjdG9yKTogVmVjdG9yID0+IHtcclxuICAgIGNvbnN0IG1hZyA9IFZlY3Rvci5tYWduaXR1ZGUodilcclxuICAgIGlmIChtYWcgPT09IDApIHJldHVybiBWZWN0b3IuY3JlYXRlKClcclxuICAgIHJldHVybiBWZWN0b3IubXVsdGlwbHkodiwgMSAvIG1hZylcclxuICB9LFxyXG4gIFxyXG4gIGRpc3RhbmNlOiAoYTogVmVjdG9yLCBiOiBWZWN0b3IpOiBudW1iZXIgPT4ge1xyXG4gICAgY29uc3QgZGlmZiA9IFZlY3Rvci5zdWJ0cmFjdChhLCBiKVxyXG4gICAgcmV0dXJuIFZlY3Rvci5tYWduaXR1ZGUoZGlmZilcclxuICB9LFxyXG4gIFxyXG4gIGxlcnA6IChhOiBWZWN0b3IsIGI6IFZlY3RvciwgdDogbnVtYmVyKTogVmVjdG9yID0+ICh7XHJcbiAgICB4OiBhLnggKyAoYi54IC0gYS54KSAqIHQsXHJcbiAgICB5OiBhLnkgKyAoYi55IC0gYS55KSAqIHRcclxuICB9KSxcclxuICBcclxuICByb3RhdGU6ICh2OiBWZWN0b3IsIGFuZ2xlOiBudW1iZXIpOiBWZWN0b3IgPT4ge1xyXG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGUpXHJcbiAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZSlcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHYueCAqIGNvcyAtIHYueSAqIHNpbixcclxuICAgICAgeTogdi54ICogc2luICsgdi55ICogY29zXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBQaHlzaWNzIHNpbXVsYXRpb24gZnVuY3Rpb25zXHJcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQaHlzaWNzV29ybGQod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBQaHlzaWNzV29ybGQge1xyXG4gIHJldHVybiB7XHJcbiAgICBlbnRpdGllczogbmV3IE1hcCgpLFxyXG4gICAgZ3Jhdml0eTogVmVjdG9yLmNyZWF0ZSgwLCAwKSwgLy8gTm8gZ3Jhdml0eSBieSBkZWZhdWx0IGZvciB0b3AtZG93biBhcmVuYVxyXG4gICAgYWlyRnJpY3Rpb246IDAuOTksXHJcbiAgICB0aW1lQWNjdW11bGF0b3I6IDAsXHJcbiAgICBmaXhlZFRpbWVTdGVwOiAxIC8gNjAsIC8vIDYwIEZQUyBwaHlzaWNzXHJcbiAgICBib3VuZHM6IHsgd2lkdGgsIGhlaWdodCB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2lyY2xlRW50aXR5KFxyXG4gIGlkOiBzdHJpbmcsXHJcbiAgeDogbnVtYmVyLFxyXG4gIHk6IG51bWJlcixcclxuICByYWRpdXM6IG51bWJlcixcclxuICB0eXBlOiBDaXJjbGVFbnRpdHlbJ3R5cGUnXSA9ICdwbGF5ZXInXHJcbik6IENpcmNsZUVudGl0eSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGlkLFxyXG4gICAgcG9zaXRpb246IFZlY3Rvci5jcmVhdGUoeCwgeSksXHJcbiAgICB2ZWxvY2l0eTogVmVjdG9yLmNyZWF0ZSgpLFxyXG4gICAgYWNjZWxlcmF0aW9uOiBWZWN0b3IuY3JlYXRlKCksXHJcbiAgICByYWRpdXMsXHJcbiAgICBtYXNzOiBNYXRoLlBJICogcmFkaXVzICogcmFkaXVzLCAvLyBBcmVhLWJhc2VkIG1hc3NcclxuICAgIGhlYWx0aDogMTAwLFxyXG4gICAgbWF4SGVhbHRoOiAxMDAsXHJcbiAgICBkYW1hZ2U6IDIwLFxyXG4gICAgcmVzdGl0dXRpb246IDEuMCwgLy8gUGVyZmVjdCBib3VuY2luZyBmb3IgY29uc3RhbnQgbW92ZW1lbnRcclxuICAgIGZyaWN0aW9uOiAxLjAsIC8vIE5vIGZyaWN0aW9uIC0gbGV0IHRoZSBzcGVlZCBtYWludGVuYW5jZSBoYW5kbGUgdGhpc1xyXG4gICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgdHlwZSxcclxuICAgIGludnVsbmVyYWJsZVVudGlsOiAwXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlsZShcclxuICBpZDogc3RyaW5nLFxyXG4gIHg6IG51bWJlcixcclxuICB5OiBudW1iZXIsXHJcbiAgZGlyZWN0aW9uOiBWZWN0b3IsXHJcbiAgc3BlZWQ6IG51bWJlcixcclxuICBvd25lcklkOiBzdHJpbmcsXHJcbiAgbGlmZXRpbWU6IG51bWJlciA9IDMwMDAsXHJcbiAgY2hhcmFjdGVyVHlwZT86IHN0cmluZ1xyXG4pOiBQcm9qZWN0aWxlIHtcclxuICBjb25zdCB2ZWxvY2l0eSA9IFZlY3Rvci5tdWx0aXBseShWZWN0b3Iubm9ybWFsaXplKGRpcmVjdGlvbiksIHNwZWVkKVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBpZCxcclxuICAgIHBvc2l0aW9uOiBWZWN0b3IuY3JlYXRlKHgsIHkpLFxyXG4gICAgdmVsb2NpdHksXHJcbiAgICBhY2NlbGVyYXRpb246IFZlY3Rvci5jcmVhdGUoKSxcclxuICAgIHJhZGl1czogNSxcclxuICAgIG1hc3M6IDEsXHJcbiAgICBoZWFsdGg6IDEsXHJcbiAgICBtYXhIZWFsdGg6IDEsXHJcbiAgICBkYW1hZ2U6IDEwLCAvLyBSZWR1Y2VkIGRlZmF1bHQgZGFtYWdlIGZyb20gMjUgdG8gMTBcclxuICAgIHJlc3RpdHV0aW9uOiAwLjIsXHJcbiAgICBmcmljdGlvbjogMSwgLy8gTm8gZnJpY3Rpb24gZm9yIHByb2plY3RpbGVzXHJcbiAgICBpc1N0YXRpYzogZmFsc2UsXHJcbiAgICB0eXBlOiAncHJvamVjdGlsZScsXHJcbiAgICBvd25lcklkLFxyXG4gICAgc3BlZWQsXHJcbiAgICBsaWZldGltZSxcclxuICAgIHBpZXJjaW5nOiAwLFxyXG4gICAgaGl0c1JlbWFpbmluZzogMSxcclxuICAgIGNoYXJhY3RlclR5cGVcclxuICB9XHJcbn1cclxuXHJcbi8vIENvbGxpc2lvbiBkZXRlY3Rpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdENvbGxpc2lvbihhOiBDaXJjbGVFbnRpdHksIGI6IENpcmNsZUVudGl0eSk6IENvbGxpc2lvbiB8IG51bGwge1xyXG4gIGNvbnN0IGRpc3RhbmNlID0gVmVjdG9yLmRpc3RhbmNlKGEucG9zaXRpb24sIGIucG9zaXRpb24pXHJcbiAgY29uc3QgbWluRGlzdGFuY2UgPSBhLnJhZGl1cyArIGIucmFkaXVzXHJcbiAgXHJcbiAgaWYgKGRpc3RhbmNlID49IG1pbkRpc3RhbmNlKSB7XHJcbiAgICByZXR1cm4gbnVsbCAvLyBObyBjb2xsaXNpb25cclxuICB9XHJcbiAgXHJcbiAgY29uc3Qgbm9ybWFsID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3Iuc3VidHJhY3QoYi5wb3NpdGlvbiwgYS5wb3NpdGlvbikpXHJcbiAgY29uc3QgcGVuZXRyYXRpb24gPSBtaW5EaXN0YW5jZSAtIGRpc3RhbmNlXHJcbiAgY29uc3QgcmVsYXRpdmVWZWxvY2l0eSA9IFZlY3Rvci5tYWduaXR1ZGUoVmVjdG9yLnN1YnRyYWN0KGEudmVsb2NpdHksIGIudmVsb2NpdHkpKVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBlbnRpdHlBOiBhLFxyXG4gICAgZW50aXR5QjogYixcclxuICAgIG5vcm1hbCxcclxuICAgIHBlbmV0cmF0aW9uLFxyXG4gICAgcmVsYXRpdmVWZWxvY2l0eVxyXG4gIH1cclxufVxyXG5cclxuLy8gQ29sbGlzaW9uIHJlc3BvbnNlIHdpdGggbW9tZW50dW0tYmFzZWQgZGFtYWdlXHJcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlQ29sbGlzaW9uKGNvbGxpc2lvbjogQ29sbGlzaW9uLCB3b3JsZDogUGh5c2ljc1dvcmxkKTogdm9pZCB7XHJcbiAgY29uc3QgeyBlbnRpdHlBLCBlbnRpdHlCLCBub3JtYWwsIHBlbmV0cmF0aW9uLCByZWxhdGl2ZVZlbG9jaXR5IH0gPSBjb2xsaXNpb25cclxuICBcclxuICAvLyBTa2lwIGlmIGVpdGhlciBlbnRpdHkgaXMgc3RhdGljIGFuZCB0aGUgb3RoZXIgaXMgYSBwcm9qZWN0aWxlXHJcbiAgaWYgKChlbnRpdHlBLmlzU3RhdGljIHx8IGVudGl0eUIuaXNTdGF0aWMpICYmIFxyXG4gICAgICAoZW50aXR5QS50eXBlID09PSAncHJvamVjdGlsZScgfHwgZW50aXR5Qi50eXBlID09PSAncHJvamVjdGlsZScpKSB7XHJcbiAgICByZXR1cm5cclxuICB9XHJcbiAgXHJcbiAgLy8gUG9zaXRpb25hbCBjb3JyZWN0aW9uIHRvIHByZXZlbnQgb3ZlcmxhcFxyXG4gIGNvbnN0IGNvcnJlY3Rpb25QZXJjZW50ID0gMC44XHJcbiAgY29uc3QgY29ycmVjdGlvbiA9IFZlY3Rvci5tdWx0aXBseShub3JtYWwsIHBlbmV0cmF0aW9uICogY29ycmVjdGlvblBlcmNlbnQpXHJcbiAgXHJcbiAgaWYgKCFlbnRpdHlBLmlzU3RhdGljICYmICFlbnRpdHlCLmlzU3RhdGljKSB7XHJcbiAgICBjb25zdCB0b3RhbE1hc3MgPSBlbnRpdHlBLm1hc3MgKyBlbnRpdHlCLm1hc3NcclxuICAgIGVudGl0eUEucG9zaXRpb24gPSBWZWN0b3Iuc3VidHJhY3QoZW50aXR5QS5wb3NpdGlvbiwgVmVjdG9yLm11bHRpcGx5KGNvcnJlY3Rpb24sIGVudGl0eUIubWFzcyAvIHRvdGFsTWFzcykpXHJcbiAgICBlbnRpdHlCLnBvc2l0aW9uID0gVmVjdG9yLmFkZChlbnRpdHlCLnBvc2l0aW9uLCBWZWN0b3IubXVsdGlwbHkoY29ycmVjdGlvbiwgZW50aXR5QS5tYXNzIC8gdG90YWxNYXNzKSlcclxuICB9IGVsc2UgaWYgKCFlbnRpdHlBLmlzU3RhdGljKSB7XHJcbiAgICBlbnRpdHlBLnBvc2l0aW9uID0gVmVjdG9yLnN1YnRyYWN0KGVudGl0eUEucG9zaXRpb24sIGNvcnJlY3Rpb24pXHJcbiAgfSBlbHNlIGlmICghZW50aXR5Qi5pc1N0YXRpYykge1xyXG4gICAgZW50aXR5Qi5wb3NpdGlvbiA9IFZlY3Rvci5hZGQoZW50aXR5Qi5wb3NpdGlvbiwgY29ycmVjdGlvbilcclxuICB9XHJcbiAgXHJcbiAgLy8gQ2FsY3VsYXRlIG1vbWVudHVtLWJhc2VkIGRhbWFnZSAocmVkdWNlZCBmb3IgbG9uZ2VyIGJhdHRsZXMpXHJcbiAgY29uc3QgYmFzZURhbWFnZSA9IE1hdGgubWF4KGVudGl0eUEuZGFtYWdlLCBlbnRpdHlCLmRhbWFnZSlcclxuICBjb25zdCBtb21lbnR1bURhbWFnZSA9IGJhc2VEYW1hZ2UgKiAwLjMgKiAoMSArIE1hdGgubWluKHJlbGF0aXZlVmVsb2NpdHkgLyA2MDAsIDEpKSAvLyBSZWR1Y2VkIGJ5IDcwJVxyXG4gIFxyXG4gIC8vIEFwcGx5IGRhbWFnZSB3aXRoIGludnVsbmVyYWJpbGl0eSBmcmFtZXNcclxuICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KClcclxuICBcclxuICBpZiAoZW50aXR5QS50eXBlICE9PSAncHJvamVjdGlsZScgJiYgZW50aXR5Qi50eXBlICE9PSAncGlja3VwJyAmJiBcclxuICAgICAgZW50aXR5QS5pbnZ1bG5lcmFibGVVbnRpbCEgPCBjdXJyZW50VGltZSkge1xyXG4gICAgZW50aXR5QS5oZWFsdGggPSBNYXRoLm1heCgwLCBlbnRpdHlBLmhlYWx0aCAtIG1vbWVudHVtRGFtYWdlKVxyXG4gICAgZW50aXR5QS5pbnZ1bG5lcmFibGVVbnRpbCA9IGN1cnJlbnRUaW1lICsgNTAwIC8vIDUwMG1zIGltbXVuaXR5XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChlbnRpdHlCLnR5cGUgIT09ICdwcm9qZWN0aWxlJyAmJiBlbnRpdHlBLnR5cGUgIT09ICdwaWNrdXAnICYmIFxyXG4gICAgICBlbnRpdHlCLmludnVsbmVyYWJsZVVudGlsISA8IGN1cnJlbnRUaW1lKSB7XHJcbiAgICBlbnRpdHlCLmhlYWx0aCA9IE1hdGgubWF4KDAsIGVudGl0eUIuaGVhbHRoIC0gbW9tZW50dW1EYW1hZ2UpXHJcbiAgICBlbnRpdHlCLmludnVsbmVyYWJsZVVudGlsID0gY3VycmVudFRpbWUgKyA1MDBcclxuICB9XHJcbiAgXHJcbiAgLy8gRWxhc3RpYyBjb2xsaXNpb24gcmVzcG9uc2UgLSBidXQgZG9uJ3QgYWZmZWN0IHByb2plY3RpbGUgdmVsb2NpdGllc1xyXG4gIGlmICghZW50aXR5QS5pc1N0YXRpYyAmJiAhZW50aXR5Qi5pc1N0YXRpYyAmJiBcclxuICAgICAgZW50aXR5QS50eXBlICE9PSAncHJvamVjdGlsZScgJiYgZW50aXR5Qi50eXBlICE9PSAncHJvamVjdGlsZScpIHtcclxuICAgIGNvbnN0IHJlbGF0aXZlVmVsID0gVmVjdG9yLnN1YnRyYWN0KGVudGl0eUEudmVsb2NpdHksIGVudGl0eUIudmVsb2NpdHkpXHJcbiAgICBjb25zdCB2ZWxBbG9uZ05vcm1hbCA9IFZlY3Rvci5kb3QocmVsYXRpdmVWZWwsIG5vcm1hbClcclxuICAgIFxyXG4gICAgaWYgKHZlbEFsb25nTm9ybWFsID4gMCkgcmV0dXJuIC8vIE9iamVjdHMgc2VwYXJhdGluZ1xyXG4gICAgXHJcbiAgICBjb25zdCByZXN0aXR1dGlvbiA9IE1hdGgubWF4KGVudGl0eUEucmVzdGl0dXRpb24sIGVudGl0eUIucmVzdGl0dXRpb24pICogMS4wNSAvLyBTbGlnaHRseSBnYWluIGVuZXJneSB0byBtYWludGFpbiBtb3ZlbWVudFxyXG4gICAgY29uc3QgaW1wdWxzZVNjYWxhciA9IC0oMSArIHJlc3RpdHV0aW9uKSAqIHZlbEFsb25nTm9ybWFsIC8gKDEvZW50aXR5QS5tYXNzICsgMS9lbnRpdHlCLm1hc3MpXHJcbiAgICBcclxuICAgIGNvbnN0IGltcHVsc2UgPSBWZWN0b3IubXVsdGlwbHkobm9ybWFsLCBpbXB1bHNlU2NhbGFyKVxyXG4gICAgXHJcbiAgICAvLyBTbWFsbCByYW5kb20gdmFyaWF0aW9uIGZvciBuYXR1cmFsIG1vdmVtZW50XHJcbiAgICBjb25zdCByYW5kb21Cb29zdCA9IFZlY3Rvci5jcmVhdGUoXHJcbiAgICAgIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDEwLFxyXG4gICAgICAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxMFxyXG4gICAgKVxyXG4gICAgXHJcbiAgICBlbnRpdHlBLnZlbG9jaXR5ID0gVmVjdG9yLmFkZChlbnRpdHlBLnZlbG9jaXR5LCBWZWN0b3IuYWRkKFZlY3Rvci5tdWx0aXBseShpbXB1bHNlLCAxL2VudGl0eUEubWFzcyksIHJhbmRvbUJvb3N0KSlcclxuICAgIGVudGl0eUIudmVsb2NpdHkgPSBWZWN0b3Iuc3VidHJhY3QoZW50aXR5Qi52ZWxvY2l0eSwgVmVjdG9yLmFkZChWZWN0b3IubXVsdGlwbHkoaW1wdWxzZSwgMS9lbnRpdHlCLm1hc3MpLCByYW5kb21Cb29zdCkpXHJcbiAgfVxyXG4gIFxyXG4gIC8vIEhhbmRsZSBwcm9qZWN0aWxlIGhpdHNcclxuICBpZiAoZW50aXR5QS50eXBlID09PSAncHJvamVjdGlsZScgfHwgZW50aXR5Qi50eXBlID09PSAncHJvamVjdGlsZScpIHtcclxuICAgIGNvbnN0IHByb2plY3RpbGUgPSBlbnRpdHlBLnR5cGUgPT09ICdwcm9qZWN0aWxlJyA/IGVudGl0eUEgYXMgUHJvamVjdGlsZSA6IGVudGl0eUIgYXMgUHJvamVjdGlsZVxyXG4gICAgY29uc3QgdGFyZ2V0ID0gZW50aXR5QS50eXBlID09PSAncHJvamVjdGlsZScgPyBlbnRpdHlCIDogZW50aXR5QVxyXG4gICAgXHJcbiAgICAvLyBQcmV2ZW50IGZyaWVuZGx5IGZpcmUgLSBwcm9qZWN0aWxlcyBkb24ndCBodXJ0IHRoZWlyIG93bmVyXHJcbiAgICBpZiAocHJvamVjdGlsZS5vd25lcklkID09PSB0YXJnZXQuaWQpIHtcclxuICAgICAgcmV0dXJuIC8vIFNraXAgZGFtYWdlIGlmIHByb2plY3RpbGUgaGl0cyBpdHMgb3duZXJcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQXBwbHkgZGFtYWdlIHRvIHRhcmdldFxyXG4gICAgaWYgKHRhcmdldC50eXBlID09PSAncGxheWVyJyAmJiB0YXJnZXQuaGVhbHRoID4gMCkge1xyXG4gICAgICBjb25zdCBwcm9qZWN0aWxlRGFtYWdlID0gcHJvamVjdGlsZS5kYW1hZ2UgfHwgMTAgLy8gUmVkdWNlZCBkZWZhdWx0IGZyb20gMjUgdG8gMTBcclxuICAgICAgdGFyZ2V0LmhlYWx0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5oZWFsdGggLSBwcm9qZWN0aWxlRGFtYWdlKVxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgZm9yIGNyaXRpY2FsIGhpdCAoaGlnaCB2ZWxvY2l0eSBpbXBhY3QpXHJcbiAgICAgIGNvbnN0IGlzQ3JpdGljYWxIaXQgPSByZWxhdGl2ZVZlbG9jaXR5ID4gNDAwXHJcbiAgICAgIFxyXG4gICAgICBpZiAoaXNDcml0aWNhbEhpdCAmJiB0YXJnZXQud2VhcG9uSWQgJiYgdGFyZ2V0LnR5cGUgPT09ICdwbGF5ZXInKSB7XHJcbiAgICAgICAgLy8gV2VhcG9uIHN3YXAgb24gY3JpdGljYWwgaGl0IC0gZHJvcCB3ZWFwb24gYXMgcGlja3VwXHJcbiAgICAgICAgc3Bhd25XZWFwb25QaWNrdXAod29ybGQsIHRhcmdldC5wb3NpdGlvbiwgdGFyZ2V0LndlYXBvbklkKVxyXG4gICAgICAgIHRhcmdldC53ZWFwb25JZCA9IHVuZGVmaW5lZFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFJlbW92ZSBwcm9qZWN0aWxlIG9yIHJlZHVjZSBwaWVyY2luZ1xyXG4gICAgaWYgKHByb2plY3RpbGUuaGl0c1JlbWFpbmluZyA8PSAxKSB7XHJcbiAgICAgIHdvcmxkLmVudGl0aWVzLmRlbGV0ZShwcm9qZWN0aWxlLmlkKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcHJvamVjdGlsZS5oaXRzUmVtYWluaW5nLS1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbi8vIENoYWluIGtub2NrYmFjayAtIHdoZW4gbW92aW5nIGNpcmNsZSBmb3JjZXMgYW5vdGhlciBpbnRvIGEgdGhpcmRcclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Q2hhaW5Lbm9ja2JhY2sod29ybGQ6IFBoeXNpY3NXb3JsZCwgY29sbGlzaW9uOiBDb2xsaXNpb24pOiB2b2lkIHtcclxuICBjb25zdCB7IGVudGl0eUEsIGVudGl0eUIgfSA9IGNvbGxpc2lvblxyXG4gIGNvbnN0IHB1c2hpbmdFbnRpdHkgPSBWZWN0b3IubWFnbml0dWRlKGVudGl0eUEudmVsb2NpdHkpID4gVmVjdG9yLm1hZ25pdHVkZShlbnRpdHlCLnZlbG9jaXR5KSA/IGVudGl0eUEgOiBlbnRpdHlCXHJcbiAgY29uc3QgcHVzaGVkRW50aXR5ID0gcHVzaGluZ0VudGl0eSA9PT0gZW50aXR5QSA/IGVudGl0eUIgOiBlbnRpdHlBXHJcbiAgXHJcbiAgLy8gRmluZCBlbnRpdGllcyB0aGF0IG1pZ2h0IGJlIGhpdCBieSB0aGUgcHVzaGVkIGVudGl0eVxyXG4gIGNvbnN0IGNoYWluUmFkaXVzID0gcHVzaGVkRW50aXR5LnJhZGl1cyArIDUwIC8vIERldGVjdGlvbiByYW5nZVxyXG4gIFxyXG4gIGZvciAoY29uc3QgW2lkLCBlbnRpdHldIG9mIHdvcmxkLmVudGl0aWVzKSB7XHJcbiAgICBpZiAoZW50aXR5LmlkID09PSBwdXNoZWRFbnRpdHkuaWQgfHwgZW50aXR5LmlkID09PSBwdXNoaW5nRW50aXR5LmlkKSBjb250aW51ZVxyXG4gICAgXHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IFZlY3Rvci5kaXN0YW5jZShwdXNoZWRFbnRpdHkucG9zaXRpb24sIGVudGl0eS5wb3NpdGlvbilcclxuICAgIGlmIChkaXN0YW5jZSA8PSBjaGFpblJhZGl1cykge1xyXG4gICAgICAvLyBBcHBseSByZWR1Y2VkIGtub2NrYmFja1xyXG4gICAgICBjb25zdCBrbm9ja2JhY2tEaXJlY3Rpb24gPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5zdWJ0cmFjdChlbnRpdHkucG9zaXRpb24sIHB1c2hlZEVudGl0eS5wb3NpdGlvbikpXHJcbiAgICAgIGNvbnN0IGtub2NrYmFja0ZvcmNlID0gVmVjdG9yLm1hZ25pdHVkZShwdXNoZWRFbnRpdHkudmVsb2NpdHkpICogMC4zIC8vIFJlZHVjZWQgZm9yY2VcclxuICAgICAgXHJcbiAgICAgIGlmICghZW50aXR5LmlzU3RhdGljKSB7XHJcbiAgICAgICAgZW50aXR5LnZlbG9jaXR5ID0gVmVjdG9yLmFkZChlbnRpdHkudmVsb2NpdHksIFZlY3Rvci5tdWx0aXBseShrbm9ja2JhY2tEaXJlY3Rpb24sIGtub2NrYmFja0ZvcmNlKSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3Bhd25XZWFwb25QaWNrdXAod29ybGQ6IFBoeXNpY3NXb3JsZCwgcG9zaXRpb246IFZlY3Rvciwgd2VhcG9uSWQ6IHN0cmluZyk6IHZvaWQge1xyXG4gIGNvbnN0IHBpY2t1cCA9IGNyZWF0ZUNpcmNsZUVudGl0eShcclxuICAgIGBwaWNrdXBfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLFxyXG4gICAgcG9zaXRpb24ueCxcclxuICAgIHBvc2l0aW9uLnksXHJcbiAgICAxNSxcclxuICAgICdwaWNrdXAnXHJcbiAgKVxyXG4gIHBpY2t1cC53ZWFwb25JZCA9IHdlYXBvbklkXHJcbiAgcGlja3VwLmlzU3RhdGljID0gdHJ1ZVxyXG4gIHBpY2t1cC5saWZldGltZSA9IDE1MDAwIC8vIDE1IHNlY29uZHNcclxuICBcclxuICB3b3JsZC5lbnRpdGllcy5zZXQocGlja3VwLmlkLCBwaWNrdXApXHJcbn1cclxuXHJcbi8vIEFwcGx5IGZyaWN0aW9uIHRvIGFsbCBlbnRpdGllc1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlGcmljdGlvbih3b3JsZDogUGh5c2ljc1dvcmxkKTogdm9pZCB7XHJcbiAgZm9yIChjb25zdCBbaWQsIGVudGl0eV0gb2Ygd29ybGQuZW50aXRpZXMpIHtcclxuICAgIGlmICghZW50aXR5LmlzU3RhdGljICYmIGVudGl0eS50eXBlICE9PSAncHJvamVjdGlsZScpIHtcclxuICAgICAgLy8gTm8gZnJpY3Rpb24gZm9yIHBsYXllcnMgLSB0aGV5IHNob3VsZCBtYWludGFpbiBjb25zdGFudCBtb3ZlbWVudCBsaWtlIGJvdW5jaW5nIGJhbGxzXHJcbiAgICAgIGlmIChlbnRpdHkudHlwZSA9PT0gJ3BsYXllcicpIHtcclxuICAgICAgICAvLyBNYWludGFpbiBjb25zdGFudCBzcGVlZCBmb3IgYm91bmNpbmcgYmFsbCBwaHlzaWNzXHJcbiAgICAgICAgY29uc3QgY3VycmVudFNwZWVkID0gVmVjdG9yLm1hZ25pdHVkZShlbnRpdHkudmVsb2NpdHkpXHJcbiAgICAgICAgY29uc3QgdGFyZ2V0U3BlZWQgPSAyNTAgLy8gQ29uc3RhbnQgYm91bmNpbmcgc3BlZWRcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY3VycmVudFNwZWVkID4gNSkgeyAvLyBPbmx5IG5vcm1hbGl6ZSBpZiBtb3ZpbmdcclxuICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IFZlY3Rvci5ub3JtYWxpemUoZW50aXR5LnZlbG9jaXR5KVxyXG4gICAgICAgICAgZW50aXR5LnZlbG9jaXR5ID0gVmVjdG9yLm11bHRpcGx5KGRpcmVjdGlvbiwgdGFyZ2V0U3BlZWQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIEFwcGx5IG5vcm1hbCBmcmljdGlvbiB0byBvdGhlciBlbnRpdGllc1xyXG4gICAgICAgIGVudGl0eS52ZWxvY2l0eSA9IFZlY3Rvci5tdWx0aXBseShlbnRpdHkudmVsb2NpdHksIGVudGl0eS5mcmljdGlvbilcclxuICAgICAgICBcclxuICAgICAgICAvLyBTdG9wIHZlcnkgc2xvdyBtb3ZlbWVudCB0byBwcmV2ZW50IGppdHRlclxyXG4gICAgICAgIGlmIChWZWN0b3IubWFnbml0dWRlKGVudGl0eS52ZWxvY2l0eSkgPCAwLjEpIHtcclxuICAgICAgICAgIGVudGl0eS52ZWxvY2l0eSA9IFZlY3Rvci5jcmVhdGUoKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gSW50ZWdyYXRlIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eSB1c2luZyBWZXJsZXQgaW50ZWdyYXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGludGVncmF0ZShlbnRpdHk6IENpcmNsZUVudGl0eSwgZHQ6IG51bWJlcik6IHZvaWQge1xyXG4gIGlmIChlbnRpdHkuaXNTdGF0aWMpIHJldHVyblxyXG4gIFxyXG4gIC8vIEFwcGx5IGdyYXZpdHlcclxuICBlbnRpdHkudmVsb2NpdHkgPSBWZWN0b3IuYWRkKGVudGl0eS52ZWxvY2l0eSwgVmVjdG9yLm11bHRpcGx5KGVudGl0eS5hY2NlbGVyYXRpb24sIGR0KSlcclxuICBcclxuICAvLyBVcGRhdGUgcG9zaXRpb25cclxuICBlbnRpdHkucG9zaXRpb24gPSBWZWN0b3IuYWRkKGVudGl0eS5wb3NpdGlvbiwgVmVjdG9yLm11bHRpcGx5KGVudGl0eS52ZWxvY2l0eSwgZHQpKVxyXG4gIFxyXG4gIC8vIFJlc2V0IGFjY2VsZXJhdGlvbiBmb3IgbmV4dCBmcmFtZVxyXG4gIGVudGl0eS5hY2NlbGVyYXRpb24gPSBWZWN0b3IuY3JlYXRlKClcclxufVxyXG5cclxuLy8gQm91bmRhcnkgY29sbGlzaW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVCb3VuZGFyeUNvbGxpc2lvbihlbnRpdHk6IENpcmNsZUVudGl0eSwgYm91bmRzOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0pOiB2b2lkIHtcclxuICBpZiAoZW50aXR5LmlzU3RhdGljIHx8IGVudGl0eS50eXBlID09PSAncHJvamVjdGlsZScpIHJldHVybiAvLyBTa2lwIHByb2plY3RpbGVzIC0gaGFuZGxlZCBzZXBhcmF0ZWx5XHJcbiAgXHJcbiAgY29uc3QgYm91bmNlRmFjdG9yID0gZW50aXR5LnJlc3RpdHV0aW9uICogMS4wIC8vIFBlcmZlY3QgYm91bmNlIHRvIG1haW50YWluIGNvbnN0YW50IG1vdmVtZW50XHJcbiAgXHJcbiAgLy8gTGVmdCBib3VuZGFyeVxyXG4gIGlmIChlbnRpdHkucG9zaXRpb24ueCAtIGVudGl0eS5yYWRpdXMgPCAwKSB7XHJcbiAgICBlbnRpdHkucG9zaXRpb24ueCA9IGVudGl0eS5yYWRpdXNcclxuICAgIGVudGl0eS52ZWxvY2l0eS54ID0gLWVudGl0eS52ZWxvY2l0eS54ICogYm91bmNlRmFjdG9yXHJcbiAgICAvLyBTbWFsbCByYW5kb20gY29tcG9uZW50IGZvciB2YXJpZXR5IGJ1dCBtYWludGFpbiBvdmVyYWxsIHNwZWVkXHJcbiAgICBlbnRpdHkudmVsb2NpdHkueSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMFxyXG4gIH1cclxuICBcclxuICAvLyBSaWdodCBib3VuZGFyeVxyXG4gIGlmIChlbnRpdHkucG9zaXRpb24ueCArIGVudGl0eS5yYWRpdXMgPiBib3VuZHMud2lkdGgpIHtcclxuICAgIGVudGl0eS5wb3NpdGlvbi54ID0gYm91bmRzLndpZHRoIC0gZW50aXR5LnJhZGl1c1xyXG4gICAgZW50aXR5LnZlbG9jaXR5LnggPSAtZW50aXR5LnZlbG9jaXR5LnggKiBib3VuY2VGYWN0b3JcclxuICAgIC8vIFNtYWxsIHJhbmRvbSBjb21wb25lbnQgZm9yIHZhcmlldHkgYnV0IG1haW50YWluIG92ZXJhbGwgc3BlZWRcclxuICAgIGVudGl0eS52ZWxvY2l0eS55ICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwXHJcbiAgfVxyXG4gIFxyXG4gIC8vIFRvcCBib3VuZGFyeVxyXG4gIGlmIChlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5yYWRpdXMgPCAwKSB7XHJcbiAgICBlbnRpdHkucG9zaXRpb24ueSA9IGVudGl0eS5yYWRpdXNcclxuICAgIGVudGl0eS52ZWxvY2l0eS55ID0gLWVudGl0eS52ZWxvY2l0eS55ICogYm91bmNlRmFjdG9yXHJcbiAgICAvLyBTbWFsbCByYW5kb20gY29tcG9uZW50IGZvciB2YXJpZXR5IGJ1dCBtYWludGFpbiBvdmVyYWxsIHNwZWVkXHJcbiAgICBlbnRpdHkudmVsb2NpdHkueCArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMFxyXG4gIH1cclxuICBcclxuICAvLyBCb3R0b20gYm91bmRhcnlcclxuICBpZiAoZW50aXR5LnBvc2l0aW9uLnkgKyBlbnRpdHkucmFkaXVzID4gYm91bmRzLmhlaWdodCkge1xyXG4gICAgZW50aXR5LnBvc2l0aW9uLnkgPSBib3VuZHMuaGVpZ2h0IC0gZW50aXR5LnJhZGl1c1xyXG4gICAgZW50aXR5LnZlbG9jaXR5LnkgPSAtZW50aXR5LnZlbG9jaXR5LnkgKiBib3VuY2VGYWN0b3JcclxuICAgIC8vIFNtYWxsIHJhbmRvbSBjb21wb25lbnQgZm9yIHZhcmlldHkgYnV0IG1haW50YWluIG92ZXJhbGwgc3BlZWRcclxuICAgIGVudGl0eS52ZWxvY2l0eS54ICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwXHJcbiAgfVxyXG59XHJcblxyXG4vLyBNYWluIHBoeXNpY3Mgc2ltdWxhdGlvbiBzdGVwXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW11bGF0ZVN0ZXAod29ybGQ6IFBoeXNpY3NXb3JsZCwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICB3b3JsZC50aW1lQWNjdW11bGF0b3IgKz0gZGVsdGFUaW1lXHJcbiAgXHJcbiAgLy8gRml4ZWQgdGltZXN0ZXAgd2l0aCBhY2N1bXVsYXRvciBwYXR0ZXJuIGZvciBkZXRlcm1pbmlzbVxyXG4gIHdoaWxlICh3b3JsZC50aW1lQWNjdW11bGF0b3IgPj0gd29ybGQuZml4ZWRUaW1lU3RlcCkge1xyXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpXHJcbiAgICBcclxuICAgIC8vIFJlbW92ZSBleHBpcmVkIGVudGl0aWVzXHJcbiAgICBmb3IgKGNvbnN0IFtpZCwgZW50aXR5XSBvZiB3b3JsZC5lbnRpdGllcykge1xyXG4gICAgICBpZiAoZW50aXR5LmxpZmV0aW1lICYmIGN1cnJlbnRUaW1lID4gKGVudGl0eS5saWZldGltZSArIChlbnRpdHkgYXMgYW55KS5zcGF3blRpbWUgfHwgMCkpIHtcclxuICAgICAgICB3b3JsZC5lbnRpdGllcy5kZWxldGUoaWQpXHJcbiAgICAgICAgY29udGludWVcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gUmVtb3ZlIGRlYWQgZW50aXRpZXNcclxuICAgICAgaWYgKGVudGl0eS5oZWFsdGggPD0gMCkge1xyXG4gICAgICAgIHdvcmxkLmVudGl0aWVzLmRlbGV0ZShpZClcclxuICAgICAgICBjb250aW51ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSB3ZWFwb24gc3lzdGVtcyBhbmQgZW5lcmd5XHJcbiAgICBmb3IgKGNvbnN0IFtpZCwgZW50aXR5XSBvZiB3b3JsZC5lbnRpdGllcykge1xyXG4gICAgICB1cGRhdGVXZWFwb25Db29sZG93bnMoZW50aXR5LCBjdXJyZW50VGltZSlcclxuICAgICAgcmVnZW5lcmF0ZUVuZXJneShlbnRpdHksIHdvcmxkLmZpeGVkVGltZVN0ZXApXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBBSSAod2lsbCBiZSBjYWxsZWQgd2l0aCB3ZWFwb25zIGZyb20gb3V0c2lkZSlcclxuICAgIGlmICgod29ybGQgYXMgYW55KS53ZWFwb25zKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW2lkLCBlbnRpdHldIG9mIHdvcmxkLmVudGl0aWVzKSB7XHJcbiAgICAgICAgaWYgKGVudGl0eS5oZWFsdGggPiAwKSB7XHJcbiAgICAgICAgICB1cGRhdGVBSShlbnRpdHksIHdvcmxkLCB3b3JsZC5maXhlZFRpbWVTdGVwLCAod29ybGQgYXMgYW55KS53ZWFwb25zKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBJbnRlZ3JhdGlvbiBzdGVwIC0gaGFuZGxlIHByb2plY3RpbGVzIHNlcGFyYXRlbHlcclxuICAgIGZvciAoY29uc3QgW2lkLCBlbnRpdHldIG9mIHdvcmxkLmVudGl0aWVzKSB7XHJcbiAgICAgIGlmIChlbnRpdHkudHlwZSA9PT0gJ3Byb2plY3RpbGUnKSB7XHJcbiAgICAgICAgLy8gUHJvamVjdGlsZXMgb25seSB1cGRhdGUgcG9zaXRpb24sIG5vIHBoeXNpY3MgaW50ZXJhY3Rpb25zXHJcbiAgICAgICAgZW50aXR5LnBvc2l0aW9uLnggKz0gZW50aXR5LnZlbG9jaXR5LnggKiB3b3JsZC5maXhlZFRpbWVTdGVwXHJcbiAgICAgICAgZW50aXR5LnBvc2l0aW9uLnkgKz0gZW50aXR5LnZlbG9jaXR5LnkgKiB3b3JsZC5maXhlZFRpbWVTdGVwXHJcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRhcmllcyBmb3IgcHJvamVjdGlsZXMgKHJlbW92ZSB3aGVuIGhpdHRpbmcgd2FsbHMpXHJcbiAgICAgICAgaWYgKGVudGl0eS5wb3NpdGlvbi54IC0gZW50aXR5LnJhZGl1cyA8PSAwIHx8IFxyXG4gICAgICAgICAgICBlbnRpdHkucG9zaXRpb24ueCArIGVudGl0eS5yYWRpdXMgPj0gd29ybGQuYm91bmRzLndpZHRoIHx8XHJcbiAgICAgICAgICAgIGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LnJhZGl1cyA8PSAwIHx8IFxyXG4gICAgICAgICAgICBlbnRpdHkucG9zaXRpb24ueSArIGVudGl0eS5yYWRpdXMgPj0gd29ybGQuYm91bmRzLmhlaWdodCkge1xyXG4gICAgICAgICAgZW50aXR5LmhlYWx0aCA9IDAgLy8gTWFyayBmb3IgcmVtb3ZhbFxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBOb3JtYWwgcGh5c2ljcyBmb3Igbm9uLXByb2plY3RpbGVzXHJcbiAgICAgICAgaW50ZWdyYXRlKGVudGl0eSwgd29ybGQuZml4ZWRUaW1lU3RlcClcclxuICAgICAgICBoYW5kbGVCb3VuZGFyeUNvbGxpc2lvbihlbnRpdHksIHdvcmxkLmJvdW5kcylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDb2xsaXNpb24gZGV0ZWN0aW9uIGFuZCByZXNwb25zZVxyXG4gICAgY29uc3QgZW50aXRpZXMgPSBBcnJheS5mcm9tKHdvcmxkLmVudGl0aWVzLnZhbHVlcygpKVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRpdGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBlbnRpdGllcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGNvbnN0IGVudGl0eUEgPSBlbnRpdGllc1tpXVxyXG4gICAgICAgIGNvbnN0IGVudGl0eUIgPSBlbnRpdGllc1tqXVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNraXAgcHJvamVjdGlsZS10by1wcm9qZWN0aWxlIGNvbGxpc2lvbnNcclxuICAgICAgICBpZiAoZW50aXR5QS50eXBlID09PSAncHJvamVjdGlsZScgJiYgZW50aXR5Qi50eXBlID09PSAncHJvamVjdGlsZScpIHtcclxuICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IGNvbGxpc2lvbiA9IGRldGVjdENvbGxpc2lvbihlbnRpdHlBLCBlbnRpdHlCKVxyXG4gICAgICAgIGlmIChjb2xsaXNpb24pIHtcclxuICAgICAgICAgIHJlc29sdmVDb2xsaXNpb24oY29sbGlzaW9uLCB3b3JsZClcclxuICAgICAgICAgIC8vIE9ubHkgYXBwbHkgY2hhaW4ga25vY2tiYWNrIGZvciBub24tcHJvamVjdGlsZSBlbnRpdGllc1xyXG4gICAgICAgICAgaWYgKGVudGl0eUEudHlwZSAhPT0gJ3Byb2plY3RpbGUnICYmIGVudGl0eUIudHlwZSAhPT0gJ3Byb2plY3RpbGUnKSB7XHJcbiAgICAgICAgICAgIGFwcGx5Q2hhaW5Lbm9ja2JhY2sod29ybGQsIGNvbGxpc2lvbilcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gQXBwbHkgZnJpY3Rpb25cclxuICAgIGFwcGx5RnJpY3Rpb24od29ybGQpXHJcbiAgICBcclxuICAgIHdvcmxkLnRpbWVBY2N1bXVsYXRvciAtPSB3b3JsZC5maXhlZFRpbWVTdGVwXHJcbiAgfVxyXG59XHJcblxyXG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyBmb3IgZXh0ZXJuYWwgdXNlXHJcbmV4cG9ydCBmdW5jdGlvbiBhZGRGb3JjZShlbnRpdHk6IENpcmNsZUVudGl0eSwgZm9yY2U6IFZlY3Rvcik6IHZvaWQge1xyXG4gIGlmICghZW50aXR5LmlzU3RhdGljKSB7XHJcbiAgICBlbnRpdHkuYWNjZWxlcmF0aW9uID0gVmVjdG9yLmFkZChlbnRpdHkuYWNjZWxlcmF0aW9uLCBWZWN0b3IubXVsdGlwbHkoZm9yY2UsIDEgLyBlbnRpdHkubWFzcykpXHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc2V0VmVsb2NpdHkoZW50aXR5OiBDaXJjbGVFbnRpdHksIHZlbG9jaXR5OiBWZWN0b3IpOiB2b2lkIHtcclxuICBpZiAoIWVudGl0eS5pc1N0YXRpYykge1xyXG4gICAgZW50aXR5LnZlbG9jaXR5ID0gdmVsb2NpdHlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0ZWxlcG9ydChlbnRpdHk6IENpcmNsZUVudGl0eSwgcG9zaXRpb246IFZlY3Rvcik6IHZvaWQge1xyXG4gIGVudGl0eS5wb3NpdGlvbiA9IHBvc2l0aW9uXHJcbn1cclxuXHJcbi8vIFdlYXBvbiBzeXN0ZW0gaW50ZWdyYXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGZpcmVXZWFwb24od29ybGQ6IFBoeXNpY3NXb3JsZCwgZW50aXR5SWQ6IHN0cmluZywgd2VhcG9uRGF0YTogYW55LCB0YXJnZXREaXJlY3Rpb246IFZlY3RvciwgY3VycmVudFRpbWU6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gIGNvbnN0IGVudGl0eSA9IHdvcmxkLmVudGl0aWVzLmdldChlbnRpdHlJZClcclxuICBpZiAoIWVudGl0eSkgcmV0dXJuIGZhbHNlXHJcbiAgXHJcbiAgLy8gQ2hlY2sgY29vbGRvd24gYW5kIGVuZXJneVxyXG4gIGNvbnN0IGNvb2xkb3duRW5kID0gZW50aXR5LndlYXBvbkNvb2xkb3ducz8uZ2V0KHdlYXBvbkRhdGEuaWQpIHx8IDBcclxuICBpZiAoY3VycmVudFRpbWUgPCBjb29sZG93bkVuZCkgcmV0dXJuIGZhbHNlXHJcbiAgaWYgKChlbnRpdHkuZW5lcmd5IHx8IDApIDwgd2VhcG9uRGF0YS5jb3N0KSByZXR1cm4gZmFsc2VcclxuICBcclxuICAvLyBVcGRhdGUgZW50aXR5IGNvb2xkb3duIGFuZCBlbmVyZ3lcclxuICBpZiAoIWVudGl0eS53ZWFwb25Db29sZG93bnMpIGVudGl0eS53ZWFwb25Db29sZG93bnMgPSBuZXcgTWFwKClcclxuICBlbnRpdHkud2VhcG9uQ29vbGRvd25zLnNldCh3ZWFwb25EYXRhLmlkLCBjdXJyZW50VGltZSArIHdlYXBvbkRhdGEuY29vbGRvd25NcylcclxuICBlbnRpdHkuZW5lcmd5ID0gKGVudGl0eS5lbmVyZ3kgfHwgMCkgLSB3ZWFwb25EYXRhLmNvc3RcclxuICBcclxuICAvLyBDcmVhdGUgd2VhcG9uIGVmZmVjdFxyXG4gIGlmICh3ZWFwb25EYXRhLnR5cGUgPT09ICdwcm9qZWN0aWxlJykge1xyXG4gICAgY29uc3QgcHJvamVjdGlsZSA9IGNyZWF0ZVdlYXBvblByb2plY3RpbGUoZW50aXR5LCB3ZWFwb25EYXRhLCB0YXJnZXREaXJlY3Rpb24sIGN1cnJlbnRUaW1lKVxyXG4gICAgd29ybGQuZW50aXRpZXMuc2V0KHByb2plY3RpbGUuaWQsIHByb2plY3RpbGUpXHJcbiAgfSBlbHNlIGlmICh3ZWFwb25EYXRhLnR5cGUgPT09ICdhdXJhJykge1xyXG4gICAgY29uc3QgYXVyYSA9IGNyZWF0ZVdlYXBvbkF1cmEoZW50aXR5LCB3ZWFwb25EYXRhLCBjdXJyZW50VGltZSlcclxuICAgIHdvcmxkLmVudGl0aWVzLnNldChhdXJhLmlkLCBhdXJhKVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gdHJ1ZVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVXZWFwb25Qcm9qZWN0aWxlKG93bmVyOiBDaXJjbGVFbnRpdHksIHdlYXBvbkRhdGE6IGFueSwgZGlyZWN0aW9uOiBWZWN0b3IsIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBXZWFwb25Qcm9qZWN0aWxlIHtcclxuICBjb25zdCBub3JtYWxpemVkRGlyID0gVmVjdG9yLm5vcm1hbGl6ZShkaXJlY3Rpb24pXHJcbiAgY29uc3Qgc3Bhd25PZmZzZXQgPSBWZWN0b3IubXVsdGlwbHkobm9ybWFsaXplZERpciwgb3duZXIucmFkaXVzICsgd2VhcG9uRGF0YS5yYWRpdXMgKyAyKVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBpZDogYHByb2plY3RpbGVfJHtjdXJyZW50VGltZX1fJHtNYXRoLnJhbmRvbSgpfWAsXHJcbiAgICB0eXBlOiAncHJvamVjdGlsZScsXHJcbiAgICB3ZWFwb25JZDogd2VhcG9uRGF0YS5pZCxcclxuICAgIG93bmVySWQ6IG93bmVyLmlkLFxyXG4gICAgcG9zaXRpb246IFZlY3Rvci5hZGQob3duZXIucG9zaXRpb24sIHNwYXduT2Zmc2V0KSxcclxuICAgIHZlbG9jaXR5OiBWZWN0b3IubXVsdGlwbHkobm9ybWFsaXplZERpciwgd2VhcG9uRGF0YS5wcm9qZWN0aWxlU3BlZWQgfHwgMjAwKSxcclxuICAgIGFjY2VsZXJhdGlvbjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICByYWRpdXM6IHdlYXBvbkRhdGEucmFkaXVzLFxyXG4gICAgbWFzczogMSxcclxuICAgIGhlYWx0aDogMSxcclxuICAgIG1heEhlYWx0aDogMSxcclxuICAgIGRhbWFnZTogd2VhcG9uRGF0YS5iYXNlRGFtYWdlLFxyXG4gICAgcmVzdGl0dXRpb246IDAuOCxcclxuICAgIGZyaWN0aW9uOiAwLjAyLFxyXG4gICAgaXNTdGF0aWM6IGZhbHNlLFxyXG4gICAgc3BlZWQ6IHdlYXBvbkRhdGEucHJvamVjdGlsZVNwZWVkIHx8IDIwMCxcclxuICAgIGxpZmV0aW1lOiB3ZWFwb25EYXRhLmxpZmV0aW1lIHx8IDIwMDAsXHJcbiAgICBwaWVyY2luZzogd2VhcG9uRGF0YS5waWVyY2luZyB8fCAwLFxyXG4gICAgaGl0c1JlbWFpbmluZzogd2VhcG9uRGF0YS5waWVyY2luZyB8fCAwLFxyXG4gICAgYm91bmNlczogd2VhcG9uRGF0YS5ib3VuY2VzIHx8IDAsXHJcbiAgICBib3VuY2VzUmVtYWluaW5nOiB3ZWFwb25EYXRhLmJvdW5jZXMgfHwgMCxcclxuICAgIHNwZWNpYWw6IHdlYXBvbkRhdGEuc3BlY2lhbCB8fCBbXSxcclxuICAgIHNwYXduVGltZTogY3VycmVudFRpbWVcclxuICB9IGFzIFdlYXBvblByb2plY3RpbGUgJiB7IHNwYXduVGltZTogbnVtYmVyIH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlV2VhcG9uQXVyYShvd25lcjogQ2lyY2xlRW50aXR5LCB3ZWFwb25EYXRhOiBhbnksIGN1cnJlbnRUaW1lOiBudW1iZXIpOiBXZWFwb25BdXJhIHtcclxuICByZXR1cm4ge1xyXG4gICAgaWQ6IGBhdXJhXyR7Y3VycmVudFRpbWV9XyR7TWF0aC5yYW5kb20oKX1gLFxyXG4gICAgdHlwZTogJ2F1cmEnLFxyXG4gICAgd2VhcG9uSWQ6IHdlYXBvbkRhdGEuaWQsXHJcbiAgICBvd25lcklkOiBvd25lci5pZCxcclxuICAgIHBvc2l0aW9uOiB7IC4uLm93bmVyLnBvc2l0aW9uIH0sXHJcbiAgICB2ZWxvY2l0eTogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICBhY2NlbGVyYXRpb246IHsgeDogMCwgeTogMCB9LFxyXG4gICAgcmFkaXVzOiB3ZWFwb25EYXRhLmF1cmFSYWRpdXMgfHwgd2VhcG9uRGF0YS5yYWRpdXMsXHJcbiAgICBtYXNzOiAwLFxyXG4gICAgaGVhbHRoOiAxLFxyXG4gICAgbWF4SGVhbHRoOiAxLFxyXG4gICAgZGFtYWdlOiB3ZWFwb25EYXRhLmJhc2VEYW1hZ2UsXHJcbiAgICByZXN0aXR1dGlvbjogMCxcclxuICAgIGZyaWN0aW9uOiAwLFxyXG4gICAgaXNTdGF0aWM6IHRydWUsXHJcbiAgICBkdXJhdGlvbjogd2VhcG9uRGF0YS5hdXJhRHVyYXRpb24gfHwgMTAwMCxcclxuICAgIHNwZWNpYWw6IHdlYXBvbkRhdGEuc3BlY2lhbCB8fCBbXSxcclxuICAgIGFmZmVjdGVkRW50aXRpZXM6IG5ldyBTZXQoKSxcclxuICAgIGxpZmV0aW1lOiB3ZWFwb25EYXRhLmF1cmFEdXJhdGlvbiB8fCAxMDAwLFxyXG4gICAgc3Bhd25UaW1lOiBjdXJyZW50VGltZVxyXG4gIH0gYXMgV2VhcG9uQXVyYSAmIHsgc3Bhd25UaW1lOiBudW1iZXIgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlV2VhcG9uQ29vbGRvd25zKGVudGl0eTogQ2lyY2xlRW50aXR5LCBjdXJyZW50VGltZTogbnVtYmVyKTogdm9pZCB7XHJcbiAgaWYgKCFlbnRpdHkud2VhcG9uQ29vbGRvd25zKSByZXR1cm5cclxuICBcclxuICBmb3IgKGNvbnN0IFt3ZWFwb25JZCwgY29vbGRvd25FbmRdIG9mIGVudGl0eS53ZWFwb25Db29sZG93bnMpIHtcclxuICAgIGlmIChjdXJyZW50VGltZSA+PSBjb29sZG93bkVuZCkge1xyXG4gICAgICBlbnRpdHkud2VhcG9uQ29vbGRvd25zLmRlbGV0ZSh3ZWFwb25JZClcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWdlbmVyYXRlRW5lcmd5KGVudGl0eTogQ2lyY2xlRW50aXR5LCBkdDogbnVtYmVyKTogdm9pZCB7XHJcbiAgaWYgKGVudGl0eS5lbmVyZ3kgIT09IHVuZGVmaW5lZCAmJiBlbnRpdHkubWF4RW5lcmd5ICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGVudGl0eS5lbmVyZ3kgPSBNYXRoLm1pbihlbnRpdHkubWF4RW5lcmd5LCBlbnRpdHkuZW5lcmd5ICsgMjAgKiBkdCkgLy8gMjAgZW5lcmd5L3NlY1xyXG4gIH1cclxufVxyXG5cclxuLy8gQUkgQ29tYmF0IFN5c3RlbVxyXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlQUkoZW50aXR5OiBDaXJjbGVFbnRpdHksIHdvcmxkOiBQaHlzaWNzV29ybGQsIGRlbHRhVGltZTogbnVtYmVyLCB3ZWFwb25zOiBhbnlbXSk6IHZvaWQge1xyXG4gIGlmICghZW50aXR5LmlkLmluY2x1ZGVzKCdhaScpICYmICFlbnRpdHkuaWQuaW5jbHVkZXMoJ2JvdCcpKSByZXR1cm5cclxuICBcclxuICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KClcclxuICBcclxuICAvLyBGaW5kIG5lYXJlc3QgZW5lbXlcclxuICBsZXQgbmVhcmVzdEVuZW15OiBDaXJjbGVFbnRpdHkgfCBudWxsID0gbnVsbFxyXG4gIGxldCBuZWFyZXN0RGlzdGFuY2UgPSBJbmZpbml0eVxyXG4gIFxyXG4gIGZvciAoY29uc3QgW2lkLCBvdGhlckVudGl0eV0gb2Ygd29ybGQuZW50aXRpZXMpIHtcclxuICAgIGlmIChvdGhlckVudGl0eSA9PT0gZW50aXR5IHx8IG90aGVyRW50aXR5LmhlYWx0aCA8PSAwKSBjb250aW51ZVxyXG4gICAgaWYgKGVudGl0eS5pZC5pbmNsdWRlcygnYm90JykgJiYgb3RoZXJFbnRpdHkuaWQuaW5jbHVkZXMoJ2JvdCcpKSBjb250aW51ZSAvLyBCb3RzIGRvbid0IGZpZ2h0IGVhY2ggb3RoZXJcclxuICAgIFxyXG4gICAgY29uc3QgZGlzdGFuY2UgPSBWZWN0b3IuZGlzdGFuY2UoZW50aXR5LnBvc2l0aW9uLCBvdGhlckVudGl0eS5wb3NpdGlvbilcclxuICAgIGlmIChkaXN0YW5jZSA8IG5lYXJlc3REaXN0YW5jZSkge1xyXG4gICAgICBuZWFyZXN0RGlzdGFuY2UgPSBkaXN0YW5jZVxyXG4gICAgICBuZWFyZXN0RW5lbXkgPSBvdGhlckVudGl0eVxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICBpZiAoIW5lYXJlc3RFbmVteSkgcmV0dXJuXHJcbiAgXHJcbiAgLy8gQUkgQmVoYXZpb3IgYmFzZWQgb24gZGlzdGFuY2UgYW5kIGhlYWx0aFxyXG4gIGNvbnN0IGhlYWx0aFJhdGlvID0gZW50aXR5LmhlYWx0aCAvIGVudGl0eS5tYXhIZWFsdGhcclxuICBjb25zdCBkaXN0YW5jZVRvRW5lbXkgPSBuZWFyZXN0RGlzdGFuY2VcclxuICBcclxuICAvLyBNb3ZlbWVudCBBSVxyXG4gIGlmIChkaXN0YW5jZVRvRW5lbXkgPiAxMDApIHtcclxuICAgIC8vIE1vdmUgdG93YXJkcyBlbmVteVxyXG4gICAgY29uc3QgZGlyZWN0aW9uID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3Iuc3VidHJhY3QobmVhcmVzdEVuZW15LnBvc2l0aW9uLCBlbnRpdHkucG9zaXRpb24pKVxyXG4gICAgY29uc3QgbW92ZUZvcmNlID0gVmVjdG9yLm11bHRpcGx5KGRpcmVjdGlvbiwgMjAwICogaGVhbHRoUmF0aW8pIC8vIFNsb3dlciB3aGVuIGh1cnRcclxuICAgIGFkZEZvcmNlKGVudGl0eSwgbW92ZUZvcmNlKVxyXG4gIH0gZWxzZSBpZiAoZGlzdGFuY2VUb0VuZW15IDwgNTAgJiYgaGVhbHRoUmF0aW8gPCAwLjMpIHtcclxuICAgIC8vIFJldHJlYXQgd2hlbiBsb3cgb24gaGVhbHRoIGFuZCB0b28gY2xvc2VcclxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnN1YnRyYWN0KGVudGl0eS5wb3NpdGlvbiwgbmVhcmVzdEVuZW15LnBvc2l0aW9uKSlcclxuICAgIGNvbnN0IHJldHJlYXRGb3JjZSA9IFZlY3Rvci5tdWx0aXBseShkaXJlY3Rpb24sIDMwMClcclxuICAgIGFkZEZvcmNlKGVudGl0eSwgcmV0cmVhdEZvcmNlKVxyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBDaXJjbGUgYXJvdW5kIGVuZW15XHJcbiAgICBjb25zdCB0b0VuZW15ID0gVmVjdG9yLnN1YnRyYWN0KG5lYXJlc3RFbmVteS5wb3NpdGlvbiwgZW50aXR5LnBvc2l0aW9uKVxyXG4gICAgY29uc3QgcGVycGVuZGljdWxhciA9IHsgeDogLXRvRW5lbXkueSwgeTogdG9FbmVteS54IH1cclxuICAgIGNvbnN0IGNpcmNsZURpcmVjdGlvbiA9IFZlY3Rvci5ub3JtYWxpemUocGVycGVuZGljdWxhcilcclxuICAgIGNvbnN0IGNpcmNsZUZvcmNlID0gVmVjdG9yLm11bHRpcGx5KGNpcmNsZURpcmVjdGlvbiwgMTUwKVxyXG4gICAgYWRkRm9yY2UoZW50aXR5LCBjaXJjbGVGb3JjZSlcclxuICB9XHJcbiAgXHJcbiAgLy8gQ29tYmF0IEFJIC0gdHJ5IHRvIGF0dGFjayBldmVyeSAxLTIgc2Vjb25kc1xyXG4gIGlmICghZW50aXR5Lmxhc3RBdHRhY2tUaW1lKSBlbnRpdHkubGFzdEF0dGFja1RpbWUgPSAwXHJcbiAgY29uc3QgdGltZVNpbmNlQXR0YWNrID0gY3VycmVudFRpbWUgLSBlbnRpdHkubGFzdEF0dGFja1RpbWVcclxuICBjb25zdCBhdHRhY2tDb29sZG93biA9IDEwMDAgKyBNYXRoLnJhbmRvbSgpICogMTAwMCAvLyAxLTIgc2Vjb25kc1xyXG4gIFxyXG4gIGlmICh0aW1lU2luY2VBdHRhY2sgPiBhdHRhY2tDb29sZG93biAmJiBkaXN0YW5jZVRvRW5lbXkgPCAyMDApIHtcclxuICAgIC8vIEZpbmQgd2VhcG9uIHRvIHVzZVxyXG4gICAgY29uc3QgYXZhaWxhYmxlV2VhcG9uID0gd2VhcG9ucy5maW5kKHcgPT4gdy5pZCA9PT0gZW50aXR5LndlYXBvbklkKVxyXG4gICAgaWYgKGF2YWlsYWJsZVdlYXBvbiAmJiBlbnRpdHkuZW5lcmd5ICYmIGVudGl0eS5lbmVyZ3kgPj0gYXZhaWxhYmxlV2VhcG9uLmNvc3QpIHtcclxuICAgICAgY29uc3QgYXR0YWNrRGlyZWN0aW9uID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3Iuc3VidHJhY3QobmVhcmVzdEVuZW15LnBvc2l0aW9uLCBlbnRpdHkucG9zaXRpb24pKVxyXG4gICAgICBcclxuICAgICAgLy8gQWRkIHNvbWUgaW5hY2N1cmFjeSB0byBtYWtlIGZpZ2h0cyBtb3JlIGludGVyZXN0aW5nXHJcbiAgICAgIGNvbnN0IGluYWNjdXJhY3kgPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAwLjNcclxuICAgICAgY29uc3QgZmluYWxEaXJlY3Rpb24gPSB7XHJcbiAgICAgICAgeDogYXR0YWNrRGlyZWN0aW9uLnggKyBpbmFjY3VyYWN5LFxyXG4gICAgICAgIHk6IGF0dGFja0RpcmVjdGlvbi55ICsgaW5hY2N1cmFjeVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoZmlyZVdlYXBvbih3b3JsZCwgZW50aXR5LmlkLCBhdmFpbGFibGVXZWFwb24sIFZlY3Rvci5ub3JtYWxpemUoZmluYWxEaXJlY3Rpb24pLCBjdXJyZW50VGltZSkpIHtcclxuICAgICAgICBlbnRpdHkubGFzdEF0dGFja1RpbWUgPSBjdXJyZW50VGltZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJWZWN0b3IiLCJjcmVhdGUiLCJ4IiwieSIsImFkZCIsImEiLCJiIiwic3VidHJhY3QiLCJtdWx0aXBseSIsInYiLCJzY2FsYXIiLCJkb3QiLCJtYWduaXR1ZGUiLCJNYXRoIiwic3FydCIsIm5vcm1hbGl6ZSIsIm1hZyIsImRpc3RhbmNlIiwiZGlmZiIsImxlcnAiLCJ0Iiwicm90YXRlIiwiYW5nbGUiLCJjb3MiLCJzaW4iLCJjcmVhdGVQaHlzaWNzV29ybGQiLCJ3aWR0aCIsImhlaWdodCIsImVudGl0aWVzIiwiTWFwIiwiZ3Jhdml0eSIsImFpckZyaWN0aW9uIiwidGltZUFjY3VtdWxhdG9yIiwiZml4ZWRUaW1lU3RlcCIsImJvdW5kcyIsImNyZWF0ZUNpcmNsZUVudGl0eSIsImlkIiwicmFkaXVzIiwidHlwZSIsInBvc2l0aW9uIiwidmVsb2NpdHkiLCJhY2NlbGVyYXRpb24iLCJtYXNzIiwiUEkiLCJoZWFsdGgiLCJtYXhIZWFsdGgiLCJkYW1hZ2UiLCJyZXN0aXR1dGlvbiIsImZyaWN0aW9uIiwiaXNTdGF0aWMiLCJpbnZ1bG5lcmFibGVVbnRpbCIsImNyZWF0ZVByb2plY3RpbGUiLCJkaXJlY3Rpb24iLCJzcGVlZCIsIm93bmVySWQiLCJsaWZldGltZSIsImNoYXJhY3RlclR5cGUiLCJwaWVyY2luZyIsImhpdHNSZW1haW5pbmciLCJkZXRlY3RDb2xsaXNpb24iLCJtaW5EaXN0YW5jZSIsIm5vcm1hbCIsInBlbmV0cmF0aW9uIiwicmVsYXRpdmVWZWxvY2l0eSIsImVudGl0eUEiLCJlbnRpdHlCIiwicmVzb2x2ZUNvbGxpc2lvbiIsImNvbGxpc2lvbiIsIndvcmxkIiwiY29ycmVjdGlvblBlcmNlbnQiLCJjb3JyZWN0aW9uIiwidG90YWxNYXNzIiwiYmFzZURhbWFnZSIsIm1heCIsIm1vbWVudHVtRGFtYWdlIiwibWluIiwiY3VycmVudFRpbWUiLCJEYXRlIiwibm93IiwicmVsYXRpdmVWZWwiLCJ2ZWxBbG9uZ05vcm1hbCIsImltcHVsc2VTY2FsYXIiLCJpbXB1bHNlIiwicmFuZG9tQm9vc3QiLCJyYW5kb20iLCJwcm9qZWN0aWxlIiwidGFyZ2V0IiwicHJvamVjdGlsZURhbWFnZSIsImlzQ3JpdGljYWxIaXQiLCJ3ZWFwb25JZCIsInNwYXduV2VhcG9uUGlja3VwIiwidW5kZWZpbmVkIiwiZGVsZXRlIiwiYXBwbHlDaGFpbktub2NrYmFjayIsInB1c2hpbmdFbnRpdHkiLCJwdXNoZWRFbnRpdHkiLCJjaGFpblJhZGl1cyIsImVudGl0eSIsImtub2NrYmFja0RpcmVjdGlvbiIsImtub2NrYmFja0ZvcmNlIiwicGlja3VwIiwidG9TdHJpbmciLCJzdWJzdHIiLCJzZXQiLCJhcHBseUZyaWN0aW9uIiwiY3VycmVudFNwZWVkIiwidGFyZ2V0U3BlZWQiLCJpbnRlZ3JhdGUiLCJkdCIsImhhbmRsZUJvdW5kYXJ5Q29sbGlzaW9uIiwiYm91bmNlRmFjdG9yIiwic2ltdWxhdGVTdGVwIiwiZGVsdGFUaW1lIiwic3Bhd25UaW1lIiwidXBkYXRlV2VhcG9uQ29vbGRvd25zIiwicmVnZW5lcmF0ZUVuZXJneSIsIndlYXBvbnMiLCJ1cGRhdGVBSSIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImkiLCJsZW5ndGgiLCJqIiwiYWRkRm9yY2UiLCJmb3JjZSIsInNldFZlbG9jaXR5IiwidGVsZXBvcnQiLCJmaXJlV2VhcG9uIiwiZW50aXR5SWQiLCJ3ZWFwb25EYXRhIiwidGFyZ2V0RGlyZWN0aW9uIiwiZ2V0IiwiY29vbGRvd25FbmQiLCJ3ZWFwb25Db29sZG93bnMiLCJlbmVyZ3kiLCJjb3N0IiwiY29vbGRvd25NcyIsImNyZWF0ZVdlYXBvblByb2plY3RpbGUiLCJhdXJhIiwiY3JlYXRlV2VhcG9uQXVyYSIsIm93bmVyIiwibm9ybWFsaXplZERpciIsInNwYXduT2Zmc2V0IiwicHJvamVjdGlsZVNwZWVkIiwiYm91bmNlcyIsImJvdW5jZXNSZW1haW5pbmciLCJzcGVjaWFsIiwiYXVyYVJhZGl1cyIsImR1cmF0aW9uIiwiYXVyYUR1cmF0aW9uIiwiYWZmZWN0ZWRFbnRpdGllcyIsIlNldCIsIm1heEVuZXJneSIsImluY2x1ZGVzIiwibmVhcmVzdEVuZW15IiwibmVhcmVzdERpc3RhbmNlIiwiSW5maW5pdHkiLCJvdGhlckVudGl0eSIsImhlYWx0aFJhdGlvIiwiZGlzdGFuY2VUb0VuZW15IiwibW92ZUZvcmNlIiwicmV0cmVhdEZvcmNlIiwidG9FbmVteSIsInBlcnBlbmRpY3VsYXIiLCJjaXJjbGVEaXJlY3Rpb24iLCJjaXJjbGVGb3JjZSIsImxhc3RBdHRhY2tUaW1lIiwidGltZVNpbmNlQXR0YWNrIiwiYXR0YWNrQ29vbGRvd24iLCJhdmFpbGFibGVXZWFwb24iLCJmaW5kIiwidyIsImF0dGFja0RpcmVjdGlvbiIsImluYWNjdXJhY3kiLCJmaW5hbERpcmVjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/physics.ts\n"));

/***/ })

});