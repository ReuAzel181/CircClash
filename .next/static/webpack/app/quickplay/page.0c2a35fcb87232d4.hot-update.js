"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/quickplay/page",{

/***/ "(app-pages-browser)/./lib/physics.ts":
/*!************************!*\
  !*** ./lib/physics.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector: function() { return /* binding */ Vector; },\n/* harmony export */   addForce: function() { return /* binding */ addForce; },\n/* harmony export */   applyChainKnockback: function() { return /* binding */ applyChainKnockback; },\n/* harmony export */   applyFriction: function() { return /* binding */ applyFriction; },\n/* harmony export */   createCircleEntity: function() { return /* binding */ createCircleEntity; },\n/* harmony export */   createPhysicsWorld: function() { return /* binding */ createPhysicsWorld; },\n/* harmony export */   createProjectile: function() { return /* binding */ createProjectile; },\n/* harmony export */   detectCollision: function() { return /* binding */ detectCollision; },\n/* harmony export */   fireWeapon: function() { return /* binding */ fireWeapon; },\n/* harmony export */   handleBoundaryCollision: function() { return /* binding */ handleBoundaryCollision; },\n/* harmony export */   integrate: function() { return /* binding */ integrate; },\n/* harmony export */   regenerateEnergy: function() { return /* binding */ regenerateEnergy; },\n/* harmony export */   resolveCollision: function() { return /* binding */ resolveCollision; },\n/* harmony export */   setVelocity: function() { return /* binding */ setVelocity; },\n/* harmony export */   simulateStep: function() { return /* binding */ simulateStep; },\n/* harmony export */   teleport: function() { return /* binding */ teleport; },\n/* harmony export */   updateAI: function() { return /* binding */ updateAI; },\n/* harmony export */   updateWeaponCooldowns: function() { return /* binding */ updateWeaponCooldowns; }\n/* harmony export */ });\n// Core physics types and functions for deterministic circle-based gameplay\n// Vector math utilities\nconst Vector = {\n    create: function() {\n        let x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n        return {\n            x,\n            y\n        };\n    },\n    add: (a, b)=>({\n            x: a.x + b.x,\n            y: a.y + b.y\n        }),\n    subtract: (a, b)=>({\n            x: a.x - b.x,\n            y: a.y - b.y\n        }),\n    multiply: (v, scalar)=>({\n            x: v.x * scalar,\n            y: v.y * scalar\n        }),\n    dot: (a, b)=>a.x * b.x + a.y * b.y,\n    magnitude: (v)=>Math.sqrt(v.x * v.x + v.y * v.y),\n    normalize: (v)=>{\n        const mag = Vector.magnitude(v);\n        if (mag === 0) return Vector.create();\n        return Vector.multiply(v, 1 / mag);\n    },\n    distance: (a, b)=>{\n        const diff = Vector.subtract(a, b);\n        return Vector.magnitude(diff);\n    },\n    lerp: (a, b, t)=>({\n            x: a.x + (b.x - a.x) * t,\n            y: a.y + (b.y - a.y) * t\n        }),\n    rotate: (v, angle)=>{\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        return {\n            x: v.x * cos - v.y * sin,\n            y: v.x * sin + v.y * cos\n        };\n    }\n};\n// Physics simulation functions\nfunction createPhysicsWorld(width, height) {\n    return {\n        entities: new Map(),\n        gravity: Vector.create(0, 0),\n        airFriction: 0.99,\n        timeAccumulator: 0,\n        fixedTimeStep: 1 / 60,\n        bounds: {\n            width,\n            height\n        }\n    };\n}\nfunction createCircleEntity(id, x, y, radius) {\n    let type = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : \"player\";\n    return {\n        id,\n        position: Vector.create(x, y),\n        velocity: Vector.create(),\n        acceleration: Vector.create(),\n        radius,\n        mass: Math.PI * radius * radius,\n        health: 100,\n        maxHealth: 100,\n        damage: 20,\n        restitution: 0.95,\n        friction: 0.98,\n        isStatic: false,\n        type,\n        invulnerableUntil: 0\n    };\n}\nfunction createProjectile(id, x, y, direction, speed, ownerId) {\n    let lifetime = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 3000;\n    const velocity = Vector.multiply(Vector.normalize(direction), speed);\n    return {\n        id,\n        position: Vector.create(x, y),\n        velocity,\n        acceleration: Vector.create(),\n        radius: 5,\n        mass: 1,\n        health: 1,\n        maxHealth: 1,\n        damage: 10,\n        restitution: 0.2,\n        friction: 1,\n        isStatic: false,\n        type: \"projectile\",\n        ownerId,\n        speed,\n        lifetime,\n        piercing: 0,\n        hitsRemaining: 1\n    };\n}\n// Collision detection\nfunction detectCollision(a, b) {\n    const distance = Vector.distance(a.position, b.position);\n    const minDistance = a.radius + b.radius;\n    if (distance >= minDistance) {\n        return null // No collision\n        ;\n    }\n    const normal = Vector.normalize(Vector.subtract(b.position, a.position));\n    const penetration = minDistance - distance;\n    const relativeVelocity = Vector.magnitude(Vector.subtract(a.velocity, b.velocity));\n    return {\n        entityA: a,\n        entityB: b,\n        normal,\n        penetration,\n        relativeVelocity\n    };\n}\n// Collision response with momentum-based damage\nfunction resolveCollision(collision, world) {\n    const { entityA, entityB, normal, penetration, relativeVelocity } = collision;\n    // Skip if either entity is static and the other is a projectile\n    if ((entityA.isStatic || entityB.isStatic) && (entityA.type === \"projectile\" || entityB.type === \"projectile\")) {\n        return;\n    }\n    // Positional correction to prevent overlap\n    const correctionPercent = 0.8;\n    const correction = Vector.multiply(normal, penetration * correctionPercent);\n    if (!entityA.isStatic && !entityB.isStatic) {\n        const totalMass = entityA.mass + entityB.mass;\n        entityA.position = Vector.subtract(entityA.position, Vector.multiply(correction, entityB.mass / totalMass));\n        entityB.position = Vector.add(entityB.position, Vector.multiply(correction, entityA.mass / totalMass));\n    } else if (!entityA.isStatic) {\n        entityA.position = Vector.subtract(entityA.position, correction);\n    } else if (!entityB.isStatic) {\n        entityB.position = Vector.add(entityB.position, correction);\n    }\n    // Calculate momentum-based damage (reduced for longer battles)\n    const baseDamage = Math.max(entityA.damage, entityB.damage);\n    const momentumDamage = baseDamage * 0.3 * (1 + Math.min(relativeVelocity / 600, 1) // Reduced by 70%\n    );\n    // Apply damage with invulnerability frames\n    const currentTime = Date.now();\n    if (entityA.type !== \"projectile\" && entityB.type !== \"pickup\" && entityA.invulnerableUntil < currentTime) {\n        entityA.health = Math.max(0, entityA.health - momentumDamage);\n        entityA.invulnerableUntil = currentTime + 500 // 500ms immunity\n        ;\n    }\n    if (entityB.type !== \"projectile\" && entityA.type !== \"pickup\" && entityB.invulnerableUntil < currentTime) {\n        entityB.health = Math.max(0, entityB.health - momentumDamage);\n        entityB.invulnerableUntil = currentTime + 500;\n    }\n    // Elastic collision response\n    if (!entityA.isStatic && !entityB.isStatic) {\n        const relativeVel = Vector.subtract(entityA.velocity, entityB.velocity);\n        const velAlongNormal = Vector.dot(relativeVel, normal);\n        if (velAlongNormal > 0) return; // Objects separating\n        const restitution = Math.max(entityA.restitution, entityB.restitution) * 0.9 // Realistic bouncing\n        ;\n        const impulseScalar = -(1 + restitution) * velAlongNormal / (1 / entityA.mass + 1 / entityB.mass);\n        const impulse = Vector.multiply(normal, impulseScalar);\n        // Small random variation for natural movement\n        const randomBoost = Vector.create((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);\n        entityA.velocity = Vector.add(entityA.velocity, Vector.add(Vector.multiply(impulse, 1 / entityA.mass), randomBoost));\n        entityB.velocity = Vector.subtract(entityB.velocity, Vector.add(Vector.multiply(impulse, 1 / entityB.mass), randomBoost));\n    }\n    // Handle projectile hits\n    if (entityA.type === \"projectile\" || entityB.type === \"projectile\") {\n        const projectile = entityA.type === \"projectile\" ? entityA : entityB;\n        const target = entityA.type === \"projectile\" ? entityB : entityA;\n        // Prevent friendly fire - projectiles don't hurt their owner\n        if (projectile.ownerId === target.id) {\n            return; // Skip damage if projectile hits its owner\n        }\n        // Apply damage to target\n        if (target.type === \"player\" && target.health > 0) {\n            const projectileDamage = projectile.damage || 10 // Reduced default from 25 to 10\n            ;\n            target.health = Math.max(0, target.health - projectileDamage);\n            // Check for critical hit (high velocity impact)\n            const isCriticalHit = relativeVelocity > 400;\n            if (isCriticalHit && target.weaponId && target.type === \"player\") {\n                // Weapon swap on critical hit - drop weapon as pickup\n                spawnWeaponPickup(world, target.position, target.weaponId);\n                target.weaponId = undefined;\n            }\n        }\n        // Remove projectile or reduce piercing\n        if (projectile.hitsRemaining <= 1) {\n            world.entities.delete(projectile.id);\n        } else {\n            projectile.hitsRemaining--;\n        }\n    }\n}\n// Chain knockback - when moving circle forces another into a third\nfunction applyChainKnockback(world, collision) {\n    const { entityA, entityB } = collision;\n    const pushingEntity = Vector.magnitude(entityA.velocity) > Vector.magnitude(entityB.velocity) ? entityA : entityB;\n    const pushedEntity = pushingEntity === entityA ? entityB : entityA;\n    // Find entities that might be hit by the pushed entity\n    const chainRadius = pushedEntity.radius + 50 // Detection range\n    ;\n    for (const [id, entity] of world.entities){\n        if (entity.id === pushedEntity.id || entity.id === pushingEntity.id) continue;\n        const distance = Vector.distance(pushedEntity.position, entity.position);\n        if (distance <= chainRadius) {\n            // Apply reduced knockback\n            const knockbackDirection = Vector.normalize(Vector.subtract(entity.position, pushedEntity.position));\n            const knockbackForce = Vector.magnitude(pushedEntity.velocity) * 0.3 // Reduced force\n            ;\n            if (!entity.isStatic) {\n                entity.velocity = Vector.add(entity.velocity, Vector.multiply(knockbackDirection, knockbackForce));\n            }\n        }\n    }\n}\nfunction spawnWeaponPickup(world, position, weaponId) {\n    const pickup = createCircleEntity(\"pickup_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9)), position.x, position.y, 15, \"pickup\");\n    pickup.weaponId = weaponId;\n    pickup.isStatic = true;\n    pickup.lifetime = 15000 // 15 seconds\n    ;\n    world.entities.set(pickup.id, pickup);\n}\n// Apply friction to all entities\nfunction applyFriction(world) {\n    for (const [id, entity] of world.entities){\n        if (!entity.isStatic && entity.type !== \"projectile\") {\n            entity.velocity = Vector.multiply(entity.velocity, entity.friction);\n            // Stop very slow movement to prevent jitter\n            if (Vector.magnitude(entity.velocity) < 0.1) {\n                entity.velocity = Vector.create();\n            }\n        }\n    }\n}\n// Integrate position and velocity using Verlet integration\nfunction integrate(entity, dt) {\n    if (entity.isStatic) return;\n    // Apply gravity\n    entity.velocity = Vector.add(entity.velocity, Vector.multiply(entity.acceleration, dt));\n    // Update position\n    entity.position = Vector.add(entity.position, Vector.multiply(entity.velocity, dt));\n    // Reset acceleration for next frame\n    entity.acceleration = Vector.create();\n}\n// Boundary collision\nfunction handleBoundaryCollision(entity, bounds) {\n    if (entity.isStatic) return;\n    // Projectiles should disappear when hitting walls (more realistic)\n    if (entity.type === \"projectile\") {\n        if (entity.position.x - entity.radius <= 0 || entity.position.x + entity.radius >= bounds.width || entity.position.y - entity.radius <= 0 || entity.position.y + entity.radius >= bounds.height) {\n            // Mark for removal by setting health to 0\n            entity.health = 0;\n            return;\n        }\n    }\n    const bounceFactor = entity.restitution * 0.95 // Slight energy loss for realistic bouncing\n    ;\n    // Left boundary\n    if (entity.position.x - entity.radius < 0) {\n        entity.position.x = entity.radius;\n        entity.velocity.x = -entity.velocity.x * bounceFactor;\n        // Small random component for variety\n        entity.velocity.y += (Math.random() - 0.5) * 20;\n    }\n    // Right boundary\n    if (entity.position.x + entity.radius > bounds.width) {\n        entity.position.x = bounds.width - entity.radius;\n        entity.velocity.x = -entity.velocity.x * bounceFactor;\n        // Small random component for variety\n        entity.velocity.y += (Math.random() - 0.5) * 20;\n    }\n    // Top boundary\n    if (entity.position.y - entity.radius < 0) {\n        entity.position.y = entity.radius;\n        entity.velocity.y = -entity.velocity.y * bounceFactor;\n        // Small random component for variety\n        entity.velocity.x += (Math.random() - 0.5) * 20;\n    }\n    // Bottom boundary\n    if (entity.position.y + entity.radius > bounds.height) {\n        entity.position.y = bounds.height - entity.radius;\n        entity.velocity.y = -entity.velocity.y * bounceFactor;\n        // Small random component for variety\n        entity.velocity.x += (Math.random() - 0.5) * 20;\n    }\n}\n// Main physics simulation step\nfunction simulateStep(world, deltaTime) {\n    world.timeAccumulator += deltaTime;\n    // Fixed timestep with accumulator pattern for determinism\n    while(world.timeAccumulator >= world.fixedTimeStep){\n        const currentTime = Date.now();\n        // Remove expired entities\n        for (const [id, entity] of world.entities){\n            if (entity.lifetime && currentTime > (entity.lifetime + entity.spawnTime || 0)) {\n                world.entities.delete(id);\n                continue;\n            }\n            // Remove dead entities\n            if (entity.health <= 0) {\n                world.entities.delete(id);\n                continue;\n            }\n        }\n        // Update weapon systems and energy\n        for (const [id, entity] of world.entities){\n            updateWeaponCooldowns(entity, currentTime);\n            regenerateEnergy(entity, world.fixedTimeStep);\n        }\n        // Update AI (will be called with weapons from outside)\n        if (world.weapons) {\n            for (const [id, entity] of world.entities){\n                if (entity.health > 0) {\n                    updateAI(entity, world, world.fixedTimeStep, world.weapons);\n                }\n            }\n        }\n        // Integration step - handle projectiles separately\n        for (const [id, entity] of world.entities){\n            if (entity.type === \"projectile\") {\n                // Projectiles only update position, no physics interactions\n                entity.position.x += entity.velocity.x * world.fixedTimeStep;\n                entity.position.y += entity.velocity.y * world.fixedTimeStep;\n                // Check boundaries for projectiles (remove when hitting walls)\n                if (entity.position.x - entity.radius <= 0 || entity.position.x + entity.radius >= world.bounds.width || entity.position.y - entity.radius <= 0 || entity.position.y + entity.radius >= world.bounds.height) {\n                    entity.health = 0 // Mark for removal\n                    ;\n                }\n            } else {\n                // Normal physics for non-projectiles\n                integrate(entity, world.fixedTimeStep);\n                handleBoundaryCollision(entity, world.bounds);\n            }\n        }\n        // Collision detection and response\n        const entities = Array.from(world.entities.values());\n        for(let i = 0; i < entities.length; i++){\n            for(let j = i + 1; j < entities.length; j++){\n                const collision = detectCollision(entities[i], entities[j]);\n                if (collision) {\n                    resolveCollision(collision, world);\n                    applyChainKnockback(world, collision);\n                }\n            }\n        }\n        // Apply friction\n        applyFriction(world);\n        world.timeAccumulator -= world.fixedTimeStep;\n    }\n}\n// Utility functions for external use\nfunction addForce(entity, force) {\n    if (!entity.isStatic) {\n        entity.acceleration = Vector.add(entity.acceleration, Vector.multiply(force, 1 / entity.mass));\n    }\n}\nfunction setVelocity(entity, velocity) {\n    if (!entity.isStatic) {\n        entity.velocity = velocity;\n    }\n}\nfunction teleport(entity, position) {\n    entity.position = position;\n}\n// Weapon system integration\nfunction fireWeapon(world, entityId, weaponData, targetDirection, currentTime) {\n    var _entity_weaponCooldowns;\n    const entity = world.entities.get(entityId);\n    if (!entity) return false;\n    // Check cooldown and energy\n    const cooldownEnd = ((_entity_weaponCooldowns = entity.weaponCooldowns) === null || _entity_weaponCooldowns === void 0 ? void 0 : _entity_weaponCooldowns.get(weaponData.id)) || 0;\n    if (currentTime < cooldownEnd) return false;\n    if ((entity.energy || 0) < weaponData.cost) return false;\n    // Update entity cooldown and energy\n    if (!entity.weaponCooldowns) entity.weaponCooldowns = new Map();\n    entity.weaponCooldowns.set(weaponData.id, currentTime + weaponData.cooldownMs);\n    entity.energy = (entity.energy || 0) - weaponData.cost;\n    // Create weapon effect\n    if (weaponData.type === \"projectile\") {\n        const projectile = createWeaponProjectile(entity, weaponData, targetDirection, currentTime);\n        world.entities.set(projectile.id, projectile);\n    } else if (weaponData.type === \"aura\") {\n        const aura = createWeaponAura(entity, weaponData, currentTime);\n        world.entities.set(aura.id, aura);\n    }\n    return true;\n}\nfunction createWeaponProjectile(owner, weaponData, direction, currentTime) {\n    const normalizedDir = Vector.normalize(direction);\n    const spawnOffset = Vector.multiply(normalizedDir, owner.radius + weaponData.radius + 2);\n    return {\n        id: \"projectile_\".concat(currentTime, \"_\").concat(Math.random()),\n        type: \"projectile\",\n        weaponId: weaponData.id,\n        ownerId: owner.id,\n        position: Vector.add(owner.position, spawnOffset),\n        velocity: Vector.multiply(normalizedDir, weaponData.projectileSpeed || 200),\n        acceleration: {\n            x: 0,\n            y: 0\n        },\n        radius: weaponData.radius,\n        mass: 1,\n        health: 1,\n        maxHealth: 1,\n        damage: weaponData.baseDamage,\n        restitution: 0.8,\n        friction: 0.02,\n        isStatic: false,\n        speed: weaponData.projectileSpeed || 200,\n        lifetime: weaponData.lifetime || 2000,\n        piercing: weaponData.piercing || 0,\n        hitsRemaining: weaponData.piercing || 0,\n        bounces: weaponData.bounces || 0,\n        bouncesRemaining: weaponData.bounces || 0,\n        special: weaponData.special || [],\n        spawnTime: currentTime\n    };\n}\nfunction createWeaponAura(owner, weaponData, currentTime) {\n    return {\n        id: \"aura_\".concat(currentTime, \"_\").concat(Math.random()),\n        type: \"aura\",\n        weaponId: weaponData.id,\n        ownerId: owner.id,\n        position: {\n            ...owner.position\n        },\n        velocity: {\n            x: 0,\n            y: 0\n        },\n        acceleration: {\n            x: 0,\n            y: 0\n        },\n        radius: weaponData.auraRadius || weaponData.radius,\n        mass: 0,\n        health: 1,\n        maxHealth: 1,\n        damage: weaponData.baseDamage,\n        restitution: 0,\n        friction: 0,\n        isStatic: true,\n        duration: weaponData.auraDuration || 1000,\n        special: weaponData.special || [],\n        affectedEntities: new Set(),\n        lifetime: weaponData.auraDuration || 1000,\n        spawnTime: currentTime\n    };\n}\nfunction updateWeaponCooldowns(entity, currentTime) {\n    if (!entity.weaponCooldowns) return;\n    for (const [weaponId, cooldownEnd] of entity.weaponCooldowns){\n        if (currentTime >= cooldownEnd) {\n            entity.weaponCooldowns.delete(weaponId);\n        }\n    }\n}\nfunction regenerateEnergy(entity, dt) {\n    if (entity.energy !== undefined && entity.maxEnergy !== undefined) {\n        entity.energy = Math.min(entity.maxEnergy, entity.energy + 20 * dt) // 20 energy/sec\n        ;\n    }\n}\n// AI Combat System\nfunction updateAI(entity, world, deltaTime, weapons) {\n    if (!entity.id.includes(\"ai\") && !entity.id.includes(\"bot\")) return;\n    const currentTime = Date.now();\n    // Find nearest enemy\n    let nearestEnemy = null;\n    let nearestDistance = Infinity;\n    for (const [id, otherEntity] of world.entities){\n        if (otherEntity === entity || otherEntity.health <= 0) continue;\n        if (entity.id.includes(\"bot\") && otherEntity.id.includes(\"bot\")) continue; // Bots don't fight each other\n        const distance = Vector.distance(entity.position, otherEntity.position);\n        if (distance < nearestDistance) {\n            nearestDistance = distance;\n            nearestEnemy = otherEntity;\n        }\n    }\n    if (!nearestEnemy) return;\n    // AI Behavior based on distance and health\n    const healthRatio = entity.health / entity.maxHealth;\n    const distanceToEnemy = nearestDistance;\n    // Movement AI\n    if (distanceToEnemy > 100) {\n        // Move towards enemy\n        const direction = Vector.normalize(Vector.subtract(nearestEnemy.position, entity.position));\n        const moveForce = Vector.multiply(direction, 200 * healthRatio) // Slower when hurt\n        ;\n        addForce(entity, moveForce);\n    } else if (distanceToEnemy < 50 && healthRatio < 0.3) {\n        // Retreat when low on health and too close\n        const direction = Vector.normalize(Vector.subtract(entity.position, nearestEnemy.position));\n        const retreatForce = Vector.multiply(direction, 300);\n        addForce(entity, retreatForce);\n    } else {\n        // Circle around enemy\n        const toEnemy = Vector.subtract(nearestEnemy.position, entity.position);\n        const perpendicular = {\n            x: -toEnemy.y,\n            y: toEnemy.x\n        };\n        const circleDirection = Vector.normalize(perpendicular);\n        const circleForce = Vector.multiply(circleDirection, 150);\n        addForce(entity, circleForce);\n    }\n    // Combat AI - try to attack every 1-2 seconds\n    if (!entity.lastAttackTime) entity.lastAttackTime = 0;\n    const timeSinceAttack = currentTime - entity.lastAttackTime;\n    const attackCooldown = 1000 + Math.random() * 1000 // 1-2 seconds\n    ;\n    if (timeSinceAttack > attackCooldown && distanceToEnemy < 200) {\n        // Find weapon to use\n        const availableWeapon = weapons.find((w)=>w.id === entity.weaponId);\n        if (availableWeapon && entity.energy && entity.energy >= availableWeapon.cost) {\n            const attackDirection = Vector.normalize(Vector.subtract(nearestEnemy.position, entity.position));\n            // Add some inaccuracy to make fights more interesting\n            const inaccuracy = (Math.random() - 0.5) * 0.3;\n            const finalDirection = {\n                x: attackDirection.x + inaccuracy,\n                y: attackDirection.y + inaccuracy\n            };\n            if (fireWeapon(world, entity.id, availableWeapon, Vector.normalize(finalDirection), currentTime)) {\n                entity.lastAttackTime = currentTime;\n            }\n        }\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFNLEtBQUssS0FBSyxjQUFjOztJQUVqRSxJQUFJa0Ysa0JBQWtCQyxrQkFBa0JULGtCQUFrQixLQUFLO1FBQzdELHFCQUFxQjtRQUNyQixNQUFNVSxrQkFBa0J0RCxRQUFRdUQsSUFBSSxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFckksRUFBRSxLQUFLNEQsT0FBT1IsUUFBUTtRQUNsRSxJQUFJK0UsbUJBQW1CdkUsT0FBT29DLE1BQU0sSUFBSXBDLE9BQU9vQyxNQUFNLElBQUltQyxnQkFBZ0JsQyxJQUFJLEVBQUU7WUFDN0UsTUFBTXFDLGtCQUFrQjFLLE9BQU9lLFNBQVMsQ0FBQ2YsT0FBT08sUUFBUSxDQUFDaUosYUFBYWpILFFBQVEsRUFBRXlELE9BQU96RCxRQUFRO1lBRS9GLHNEQUFzRDtZQUN0RCxNQUFNb0ksYUFBYSxDQUFDOUosS0FBS3NFLE1BQU0sS0FBSyxHQUFFLElBQUs7WUFDM0MsTUFBTXlGLGlCQUFpQjtnQkFDckIxSyxHQUFHd0ssZ0JBQWdCeEssQ0FBQyxHQUFHeUs7Z0JBQ3ZCeEssR0FBR3VLLGdCQUFnQnZLLENBQUMsR0FBR3dLO1lBQ3pCO1lBRUEsSUFBSTlDLFdBQVcxRCxPQUFPNkIsT0FBTzVELEVBQUUsRUFBRW1JLGlCQUFpQnZLLE9BQU9lLFNBQVMsQ0FBQzZKLGlCQUFpQmpHLGNBQWM7Z0JBQ2hHcUIsT0FBT29FLGNBQWMsR0FBR3pGO1lBQzFCO1FBQ0Y7SUFDRjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9waHlzaWNzLnRzPzU4ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29yZSBwaHlzaWNzIHR5cGVzIGFuZCBmdW5jdGlvbnMgZm9yIGRldGVybWluaXN0aWMgY2lyY2xlLWJhc2VkIGdhbWVwbGF5XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFZlY3RvciB7XHJcbiAgeDogbnVtYmVyXHJcbiAgeTogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2lyY2xlRW50aXR5IHtcclxuICBpZDogc3RyaW5nXHJcbiAgcG9zaXRpb246IFZlY3RvclxyXG4gIHZlbG9jaXR5OiBWZWN0b3JcclxuICBhY2NlbGVyYXRpb246IFZlY3RvclxyXG4gIHJhZGl1czogbnVtYmVyXHJcbiAgbWFzczogbnVtYmVyXHJcbiAgaGVhbHRoOiBudW1iZXJcclxuICBtYXhIZWFsdGg6IG51bWJlclxyXG4gIGRhbWFnZTogbnVtYmVyXHJcbiAgd2VhcG9uSWQ/OiBzdHJpbmdcclxuICByZXN0aXR1dGlvbjogbnVtYmVyIC8vIEJvdW5jZSBjb2VmZmljaWVudCAoMC0xKVxyXG4gIGZyaWN0aW9uOiBudW1iZXIgLy8gTW92ZW1lbnQgZnJpY3Rpb24gKDAtMSlcclxuICBpc1N0YXRpYzogYm9vbGVhbiAvLyBJbW1vdmFibGUgb2JqZWN0c1xyXG4gIHR5cGU6ICdwbGF5ZXInIHwgJ3Byb2plY3RpbGUnIHwgJ3BpY2t1cCcgfCAnaGF6YXJkJyB8ICdhdXJhJ1xyXG4gIG93bmVySWQ/OiBzdHJpbmcgLy8gRm9yIHByb2plY3RpbGVzXHJcbiAgbGlmZXRpbWU/OiBudW1iZXIgLy8gRm9yIHRlbXBvcmFyeSBlbnRpdGllc1xyXG4gIGludnVsbmVyYWJsZVVudGlsPzogbnVtYmVyIC8vIEltbXVuaXR5IGZyYW1lc1xyXG4gIC8vIFdlYXBvbiBzeXN0ZW1cclxuICBlcXVpcHBlZFdlYXBvbj86IHN0cmluZ1xyXG4gIHdlYXBvbkNvb2xkb3ducz86IE1hcDxzdHJpbmcsIG51bWJlcj5cclxuICBlbmVyZ3k/OiBudW1iZXJcclxuICBtYXhFbmVyZ3k/OiBudW1iZXJcclxuICBzcGVjaWFsPzogc3RyaW5nW10gLy8gU3BlY2lhbCBiZWhhdmlvciBmbGFnc1xyXG4gIC8vIEFJIHN5c3RlbVxyXG4gIGxhc3RBdHRhY2tUaW1lPzogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgV2VhcG9uUHJvamVjdGlsZSBleHRlbmRzIENpcmNsZUVudGl0eSB7XHJcbiAgdHlwZTogJ3Byb2plY3RpbGUnXHJcbiAgd2VhcG9uSWQ6IHN0cmluZ1xyXG4gIHNwZWVkOiBudW1iZXJcclxuICBsaWZldGltZTogbnVtYmVyXHJcbiAgcGllcmNpbmc6IG51bWJlciAvLyBIb3cgbWFueSBlbnRpdGllcyBpdCBjYW4gaGl0XHJcbiAgaGl0c1JlbWFpbmluZzogbnVtYmVyXHJcbiAgYm91bmNlczogbnVtYmVyXHJcbiAgYm91bmNlc1JlbWFpbmluZzogbnVtYmVyXHJcbiAgc3BlY2lhbDogc3RyaW5nW11cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBXZWFwb25BdXJhIGV4dGVuZHMgQ2lyY2xlRW50aXR5IHtcclxuICB0eXBlOiAnYXVyYSdcclxuICB3ZWFwb25JZDogc3RyaW5nXHJcbiAgZHVyYXRpb246IG51bWJlclxyXG4gIHNwZWNpYWw6IHN0cmluZ1tdXHJcbiAgYWZmZWN0ZWRFbnRpdGllczogU2V0PHN0cmluZz4gLy8gVHJhY2sgd2hpY2ggZW50aXRpZXMgYXJlIGluIHJhbmdlXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdGlsZSBleHRlbmRzIENpcmNsZUVudGl0eSB7XHJcbiAgdHlwZTogJ3Byb2plY3RpbGUnXHJcbiAgc3BlZWQ6IG51bWJlclxyXG4gIGxpZmV0aW1lOiBudW1iZXJcclxuICBwaWVyY2luZzogbnVtYmVyIC8vIEhvdyBtYW55IGVudGl0aWVzIGl0IGNhbiBoaXRcclxuICBoaXRzUmVtYWluaW5nOiBudW1iZXJcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDb2xsaXNpb24ge1xyXG4gIGVudGl0eUE6IENpcmNsZUVudGl0eVxyXG4gIGVudGl0eUI6IENpcmNsZUVudGl0eVxyXG4gIG5vcm1hbDogVmVjdG9yXHJcbiAgcGVuZXRyYXRpb246IG51bWJlclxyXG4gIHJlbGF0aXZlVmVsb2NpdHk6IG51bWJlclxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBoeXNpY3NXb3JsZCB7XHJcbiAgZW50aXRpZXM6IE1hcDxzdHJpbmcsIENpcmNsZUVudGl0eT5cclxuICBncmF2aXR5OiBWZWN0b3JcclxuICBhaXJGcmljdGlvbjogbnVtYmVyXHJcbiAgdGltZUFjY3VtdWxhdG9yOiBudW1iZXJcclxuICBmaXhlZFRpbWVTdGVwOiBudW1iZXIgLy8gMS82MCBmb3IgNjBmcHMgcGh5c2ljc1xyXG4gIGJvdW5kczogeyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9XHJcbn1cclxuXHJcbi8vIFZlY3RvciBtYXRoIHV0aWxpdGllc1xyXG5leHBvcnQgY29uc3QgVmVjdG9yID0ge1xyXG4gIGNyZWF0ZTogKHg6IG51bWJlciA9IDAsIHk6IG51bWJlciA9IDApOiBWZWN0b3IgPT4gKHsgeCwgeSB9KSxcclxuICBcclxuICBhZGQ6IChhOiBWZWN0b3IsIGI6IFZlY3Rvcik6IFZlY3RvciA9PiAoe1xyXG4gICAgeDogYS54ICsgYi54LFxyXG4gICAgeTogYS55ICsgYi55XHJcbiAgfSksXHJcbiAgXHJcbiAgc3VidHJhY3Q6IChhOiBWZWN0b3IsIGI6IFZlY3Rvcik6IFZlY3RvciA9PiAoe1xyXG4gICAgeDogYS54IC0gYi54LFxyXG4gICAgeTogYS55IC0gYi55XHJcbiAgfSksXHJcbiAgXHJcbiAgbXVsdGlwbHk6ICh2OiBWZWN0b3IsIHNjYWxhcjogbnVtYmVyKTogVmVjdG9yID0+ICh7XHJcbiAgICB4OiB2LnggKiBzY2FsYXIsXHJcbiAgICB5OiB2LnkgKiBzY2FsYXJcclxuICB9KSxcclxuICBcclxuICBkb3Q6IChhOiBWZWN0b3IsIGI6IFZlY3Rvcik6IG51bWJlciA9PiBhLnggKiBiLnggKyBhLnkgKiBiLnksXHJcbiAgXHJcbiAgbWFnbml0dWRlOiAodjogVmVjdG9yKTogbnVtYmVyID0+IE1hdGguc3FydCh2LnggKiB2LnggKyB2LnkgKiB2LnkpLFxyXG4gIFxyXG4gIG5vcm1hbGl6ZTogKHY6IFZlY3Rvcik6IFZlY3RvciA9PiB7XHJcbiAgICBjb25zdCBtYWcgPSBWZWN0b3IubWFnbml0dWRlKHYpXHJcbiAgICBpZiAobWFnID09PSAwKSByZXR1cm4gVmVjdG9yLmNyZWF0ZSgpXHJcbiAgICByZXR1cm4gVmVjdG9yLm11bHRpcGx5KHYsIDEgLyBtYWcpXHJcbiAgfSxcclxuICBcclxuICBkaXN0YW5jZTogKGE6IFZlY3RvciwgYjogVmVjdG9yKTogbnVtYmVyID0+IHtcclxuICAgIGNvbnN0IGRpZmYgPSBWZWN0b3Iuc3VidHJhY3QoYSwgYilcclxuICAgIHJldHVybiBWZWN0b3IubWFnbml0dWRlKGRpZmYpXHJcbiAgfSxcclxuICBcclxuICBsZXJwOiAoYTogVmVjdG9yLCBiOiBWZWN0b3IsIHQ6IG51bWJlcik6IFZlY3RvciA9PiAoe1xyXG4gICAgeDogYS54ICsgKGIueCAtIGEueCkgKiB0LFxyXG4gICAgeTogYS55ICsgKGIueSAtIGEueSkgKiB0XHJcbiAgfSksXHJcbiAgXHJcbiAgcm90YXRlOiAodjogVmVjdG9yLCBhbmdsZTogbnVtYmVyKTogVmVjdG9yID0+IHtcclxuICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlKVxyXG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGUpXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiB2LnggKiBjb3MgLSB2LnkgKiBzaW4sXHJcbiAgICAgIHk6IHYueCAqIHNpbiArIHYueSAqIGNvc1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gUGh5c2ljcyBzaW11bGF0aW9uIGZ1bmN0aW9uc1xyXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGh5c2ljc1dvcmxkKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogUGh5c2ljc1dvcmxkIHtcclxuICByZXR1cm4ge1xyXG4gICAgZW50aXRpZXM6IG5ldyBNYXAoKSxcclxuICAgIGdyYXZpdHk6IFZlY3Rvci5jcmVhdGUoMCwgMCksIC8vIE5vIGdyYXZpdHkgYnkgZGVmYXVsdCBmb3IgdG9wLWRvd24gYXJlbmFcclxuICAgIGFpckZyaWN0aW9uOiAwLjk5LFxyXG4gICAgdGltZUFjY3VtdWxhdG9yOiAwLFxyXG4gICAgZml4ZWRUaW1lU3RlcDogMSAvIDYwLCAvLyA2MCBGUFMgcGh5c2ljc1xyXG4gICAgYm91bmRzOiB7IHdpZHRoLCBoZWlnaHQgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNpcmNsZUVudGl0eShcclxuICBpZDogc3RyaW5nLFxyXG4gIHg6IG51bWJlcixcclxuICB5OiBudW1iZXIsXHJcbiAgcmFkaXVzOiBudW1iZXIsXHJcbiAgdHlwZTogQ2lyY2xlRW50aXR5Wyd0eXBlJ10gPSAncGxheWVyJ1xyXG4pOiBDaXJjbGVFbnRpdHkge1xyXG4gIHJldHVybiB7XHJcbiAgICBpZCxcclxuICAgIHBvc2l0aW9uOiBWZWN0b3IuY3JlYXRlKHgsIHkpLFxyXG4gICAgdmVsb2NpdHk6IFZlY3Rvci5jcmVhdGUoKSxcclxuICAgIGFjY2VsZXJhdGlvbjogVmVjdG9yLmNyZWF0ZSgpLFxyXG4gICAgcmFkaXVzLFxyXG4gICAgbWFzczogTWF0aC5QSSAqIHJhZGl1cyAqIHJhZGl1cywgLy8gQXJlYS1iYXNlZCBtYXNzXHJcbiAgICBoZWFsdGg6IDEwMCxcclxuICAgIG1heEhlYWx0aDogMTAwLFxyXG4gICAgZGFtYWdlOiAyMCxcclxuICAgIHJlc3RpdHV0aW9uOiAwLjk1LCAvLyBJbmNyZWFzZWQgYm91bmNpbmdcclxuICAgIGZyaWN0aW9uOiAwLjk4LCAvLyBSZWR1Y2VkIGZyaWN0aW9uIGZvciBmYXN0ZXIgbW92ZW1lbnRcclxuICAgIGlzU3RhdGljOiBmYWxzZSxcclxuICAgIHR5cGUsXHJcbiAgICBpbnZ1bG5lcmFibGVVbnRpbDogMFxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb2plY3RpbGUoXHJcbiAgaWQ6IHN0cmluZyxcclxuICB4OiBudW1iZXIsXHJcbiAgeTogbnVtYmVyLFxyXG4gIGRpcmVjdGlvbjogVmVjdG9yLFxyXG4gIHNwZWVkOiBudW1iZXIsXHJcbiAgb3duZXJJZDogc3RyaW5nLFxyXG4gIGxpZmV0aW1lOiBudW1iZXIgPSAzMDAwXHJcbik6IFByb2plY3RpbGUge1xyXG4gIGNvbnN0IHZlbG9jaXR5ID0gVmVjdG9yLm11bHRpcGx5KFZlY3Rvci5ub3JtYWxpemUoZGlyZWN0aW9uKSwgc3BlZWQpXHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGlkLFxyXG4gICAgcG9zaXRpb246IFZlY3Rvci5jcmVhdGUoeCwgeSksXHJcbiAgICB2ZWxvY2l0eSxcclxuICAgIGFjY2VsZXJhdGlvbjogVmVjdG9yLmNyZWF0ZSgpLFxyXG4gICAgcmFkaXVzOiA1LFxyXG4gICAgbWFzczogMSxcclxuICAgIGhlYWx0aDogMSxcclxuICAgIG1heEhlYWx0aDogMSxcclxuICAgIGRhbWFnZTogMTAsIC8vIFJlZHVjZWQgZGVmYXVsdCBkYW1hZ2UgZnJvbSAyNSB0byAxMFxyXG4gICAgcmVzdGl0dXRpb246IDAuMixcclxuICAgIGZyaWN0aW9uOiAxLCAvLyBObyBmcmljdGlvbiBmb3IgcHJvamVjdGlsZXNcclxuICAgIGlzU3RhdGljOiBmYWxzZSxcclxuICAgIHR5cGU6ICdwcm9qZWN0aWxlJyxcclxuICAgIG93bmVySWQsXHJcbiAgICBzcGVlZCxcclxuICAgIGxpZmV0aW1lLFxyXG4gICAgcGllcmNpbmc6IDAsXHJcbiAgICBoaXRzUmVtYWluaW5nOiAxXHJcbiAgfVxyXG59XHJcblxyXG4vLyBDb2xsaXNpb24gZGV0ZWN0aW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RDb2xsaXNpb24oYTogQ2lyY2xlRW50aXR5LCBiOiBDaXJjbGVFbnRpdHkpOiBDb2xsaXNpb24gfCBudWxsIHtcclxuICBjb25zdCBkaXN0YW5jZSA9IFZlY3Rvci5kaXN0YW5jZShhLnBvc2l0aW9uLCBiLnBvc2l0aW9uKVxyXG4gIGNvbnN0IG1pbkRpc3RhbmNlID0gYS5yYWRpdXMgKyBiLnJhZGl1c1xyXG4gIFxyXG4gIGlmIChkaXN0YW5jZSA+PSBtaW5EaXN0YW5jZSkge1xyXG4gICAgcmV0dXJuIG51bGwgLy8gTm8gY29sbGlzaW9uXHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IG5vcm1hbCA9IFZlY3Rvci5ub3JtYWxpemUoVmVjdG9yLnN1YnRyYWN0KGIucG9zaXRpb24sIGEucG9zaXRpb24pKVxyXG4gIGNvbnN0IHBlbmV0cmF0aW9uID0gbWluRGlzdGFuY2UgLSBkaXN0YW5jZVxyXG4gIGNvbnN0IHJlbGF0aXZlVmVsb2NpdHkgPSBWZWN0b3IubWFnbml0dWRlKFZlY3Rvci5zdWJ0cmFjdChhLnZlbG9jaXR5LCBiLnZlbG9jaXR5KSlcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgZW50aXR5QTogYSxcclxuICAgIGVudGl0eUI6IGIsXHJcbiAgICBub3JtYWwsXHJcbiAgICBwZW5ldHJhdGlvbixcclxuICAgIHJlbGF0aXZlVmVsb2NpdHlcclxuICB9XHJcbn1cclxuXHJcbi8vIENvbGxpc2lvbiByZXNwb25zZSB3aXRoIG1vbWVudHVtLWJhc2VkIGRhbWFnZVxyXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUNvbGxpc2lvbihjb2xsaXNpb246IENvbGxpc2lvbiwgd29ybGQ6IFBoeXNpY3NXb3JsZCk6IHZvaWQge1xyXG4gIGNvbnN0IHsgZW50aXR5QSwgZW50aXR5Qiwgbm9ybWFsLCBwZW5ldHJhdGlvbiwgcmVsYXRpdmVWZWxvY2l0eSB9ID0gY29sbGlzaW9uXHJcbiAgXHJcbiAgLy8gU2tpcCBpZiBlaXRoZXIgZW50aXR5IGlzIHN0YXRpYyBhbmQgdGhlIG90aGVyIGlzIGEgcHJvamVjdGlsZVxyXG4gIGlmICgoZW50aXR5QS5pc1N0YXRpYyB8fCBlbnRpdHlCLmlzU3RhdGljKSAmJiBcclxuICAgICAgKGVudGl0eUEudHlwZSA9PT0gJ3Byb2plY3RpbGUnIHx8IGVudGl0eUIudHlwZSA9PT0gJ3Byb2plY3RpbGUnKSkge1xyXG4gICAgcmV0dXJuXHJcbiAgfVxyXG4gIFxyXG4gIC8vIFBvc2l0aW9uYWwgY29ycmVjdGlvbiB0byBwcmV2ZW50IG92ZXJsYXBcclxuICBjb25zdCBjb3JyZWN0aW9uUGVyY2VudCA9IDAuOFxyXG4gIGNvbnN0IGNvcnJlY3Rpb24gPSBWZWN0b3IubXVsdGlwbHkobm9ybWFsLCBwZW5ldHJhdGlvbiAqIGNvcnJlY3Rpb25QZXJjZW50KVxyXG4gIFxyXG4gIGlmICghZW50aXR5QS5pc1N0YXRpYyAmJiAhZW50aXR5Qi5pc1N0YXRpYykge1xyXG4gICAgY29uc3QgdG90YWxNYXNzID0gZW50aXR5QS5tYXNzICsgZW50aXR5Qi5tYXNzXHJcbiAgICBlbnRpdHlBLnBvc2l0aW9uID0gVmVjdG9yLnN1YnRyYWN0KGVudGl0eUEucG9zaXRpb24sIFZlY3Rvci5tdWx0aXBseShjb3JyZWN0aW9uLCBlbnRpdHlCLm1hc3MgLyB0b3RhbE1hc3MpKVxyXG4gICAgZW50aXR5Qi5wb3NpdGlvbiA9IFZlY3Rvci5hZGQoZW50aXR5Qi5wb3NpdGlvbiwgVmVjdG9yLm11bHRpcGx5KGNvcnJlY3Rpb24sIGVudGl0eUEubWFzcyAvIHRvdGFsTWFzcykpXHJcbiAgfSBlbHNlIGlmICghZW50aXR5QS5pc1N0YXRpYykge1xyXG4gICAgZW50aXR5QS5wb3NpdGlvbiA9IFZlY3Rvci5zdWJ0cmFjdChlbnRpdHlBLnBvc2l0aW9uLCBjb3JyZWN0aW9uKVxyXG4gIH0gZWxzZSBpZiAoIWVudGl0eUIuaXNTdGF0aWMpIHtcclxuICAgIGVudGl0eUIucG9zaXRpb24gPSBWZWN0b3IuYWRkKGVudGl0eUIucG9zaXRpb24sIGNvcnJlY3Rpb24pXHJcbiAgfVxyXG4gIFxyXG4gIC8vIENhbGN1bGF0ZSBtb21lbnR1bS1iYXNlZCBkYW1hZ2UgKHJlZHVjZWQgZm9yIGxvbmdlciBiYXR0bGVzKVxyXG4gIGNvbnN0IGJhc2VEYW1hZ2UgPSBNYXRoLm1heChlbnRpdHlBLmRhbWFnZSwgZW50aXR5Qi5kYW1hZ2UpXHJcbiAgY29uc3QgbW9tZW50dW1EYW1hZ2UgPSBiYXNlRGFtYWdlICogMC4zICogKDEgKyBNYXRoLm1pbihyZWxhdGl2ZVZlbG9jaXR5IC8gNjAwLCAxKSkgLy8gUmVkdWNlZCBieSA3MCVcclxuICBcclxuICAvLyBBcHBseSBkYW1hZ2Ugd2l0aCBpbnZ1bG5lcmFiaWxpdHkgZnJhbWVzXHJcbiAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpXHJcbiAgXHJcbiAgaWYgKGVudGl0eUEudHlwZSAhPT0gJ3Byb2plY3RpbGUnICYmIGVudGl0eUIudHlwZSAhPT0gJ3BpY2t1cCcgJiYgXHJcbiAgICAgIGVudGl0eUEuaW52dWxuZXJhYmxlVW50aWwhIDwgY3VycmVudFRpbWUpIHtcclxuICAgIGVudGl0eUEuaGVhbHRoID0gTWF0aC5tYXgoMCwgZW50aXR5QS5oZWFsdGggLSBtb21lbnR1bURhbWFnZSlcclxuICAgIGVudGl0eUEuaW52dWxuZXJhYmxlVW50aWwgPSBjdXJyZW50VGltZSArIDUwMCAvLyA1MDBtcyBpbW11bml0eVxyXG4gIH1cclxuICBcclxuICBpZiAoZW50aXR5Qi50eXBlICE9PSAncHJvamVjdGlsZScgJiYgZW50aXR5QS50eXBlICE9PSAncGlja3VwJyAmJiBcclxuICAgICAgZW50aXR5Qi5pbnZ1bG5lcmFibGVVbnRpbCEgPCBjdXJyZW50VGltZSkge1xyXG4gICAgZW50aXR5Qi5oZWFsdGggPSBNYXRoLm1heCgwLCBlbnRpdHlCLmhlYWx0aCAtIG1vbWVudHVtRGFtYWdlKVxyXG4gICAgZW50aXR5Qi5pbnZ1bG5lcmFibGVVbnRpbCA9IGN1cnJlbnRUaW1lICsgNTAwXHJcbiAgfVxyXG4gIFxyXG4gIC8vIEVsYXN0aWMgY29sbGlzaW9uIHJlc3BvbnNlXHJcbiAgaWYgKCFlbnRpdHlBLmlzU3RhdGljICYmICFlbnRpdHlCLmlzU3RhdGljKSB7XHJcbiAgICBjb25zdCByZWxhdGl2ZVZlbCA9IFZlY3Rvci5zdWJ0cmFjdChlbnRpdHlBLnZlbG9jaXR5LCBlbnRpdHlCLnZlbG9jaXR5KVxyXG4gICAgY29uc3QgdmVsQWxvbmdOb3JtYWwgPSBWZWN0b3IuZG90KHJlbGF0aXZlVmVsLCBub3JtYWwpXHJcbiAgICBcclxuICAgIGlmICh2ZWxBbG9uZ05vcm1hbCA+IDApIHJldHVybiAvLyBPYmplY3RzIHNlcGFyYXRpbmdcclxuICAgIFxyXG4gICAgY29uc3QgcmVzdGl0dXRpb24gPSBNYXRoLm1heChlbnRpdHlBLnJlc3RpdHV0aW9uLCBlbnRpdHlCLnJlc3RpdHV0aW9uKSAqIDAuOSAvLyBSZWFsaXN0aWMgYm91bmNpbmdcclxuICAgIGNvbnN0IGltcHVsc2VTY2FsYXIgPSAtKDEgKyByZXN0aXR1dGlvbikgKiB2ZWxBbG9uZ05vcm1hbCAvICgxL2VudGl0eUEubWFzcyArIDEvZW50aXR5Qi5tYXNzKVxyXG4gICAgXHJcbiAgICBjb25zdCBpbXB1bHNlID0gVmVjdG9yLm11bHRpcGx5KG5vcm1hbCwgaW1wdWxzZVNjYWxhcilcclxuICAgIFxyXG4gICAgLy8gU21hbGwgcmFuZG9tIHZhcmlhdGlvbiBmb3IgbmF0dXJhbCBtb3ZlbWVudFxyXG4gICAgY29uc3QgcmFuZG9tQm9vc3QgPSBWZWN0b3IuY3JlYXRlKFxyXG4gICAgICAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxMCxcclxuICAgICAgKE1hdGgucmFuZG9tKCkgLSAwLjUpICogMTBcclxuICAgIClcclxuICAgIFxyXG4gICAgZW50aXR5QS52ZWxvY2l0eSA9IFZlY3Rvci5hZGQoZW50aXR5QS52ZWxvY2l0eSwgVmVjdG9yLmFkZChWZWN0b3IubXVsdGlwbHkoaW1wdWxzZSwgMS9lbnRpdHlBLm1hc3MpLCByYW5kb21Cb29zdCkpXHJcbiAgICBlbnRpdHlCLnZlbG9jaXR5ID0gVmVjdG9yLnN1YnRyYWN0KGVudGl0eUIudmVsb2NpdHksIFZlY3Rvci5hZGQoVmVjdG9yLm11bHRpcGx5KGltcHVsc2UsIDEvZW50aXR5Qi5tYXNzKSwgcmFuZG9tQm9vc3QpKVxyXG4gIH1cclxuICBcclxuICAvLyBIYW5kbGUgcHJvamVjdGlsZSBoaXRzXHJcbiAgaWYgKGVudGl0eUEudHlwZSA9PT0gJ3Byb2plY3RpbGUnIHx8IGVudGl0eUIudHlwZSA9PT0gJ3Byb2plY3RpbGUnKSB7XHJcbiAgICBjb25zdCBwcm9qZWN0aWxlID0gZW50aXR5QS50eXBlID09PSAncHJvamVjdGlsZScgPyBlbnRpdHlBIGFzIFByb2plY3RpbGUgOiBlbnRpdHlCIGFzIFByb2plY3RpbGVcclxuICAgIGNvbnN0IHRhcmdldCA9IGVudGl0eUEudHlwZSA9PT0gJ3Byb2plY3RpbGUnID8gZW50aXR5QiA6IGVudGl0eUFcclxuICAgIFxyXG4gICAgLy8gUHJldmVudCBmcmllbmRseSBmaXJlIC0gcHJvamVjdGlsZXMgZG9uJ3QgaHVydCB0aGVpciBvd25lclxyXG4gICAgaWYgKHByb2plY3RpbGUub3duZXJJZCA9PT0gdGFyZ2V0LmlkKSB7XHJcbiAgICAgIHJldHVybiAvLyBTa2lwIGRhbWFnZSBpZiBwcm9qZWN0aWxlIGhpdHMgaXRzIG93bmVyXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIEFwcGx5IGRhbWFnZSB0byB0YXJnZXRcclxuICAgIGlmICh0YXJnZXQudHlwZSA9PT0gJ3BsYXllcicgJiYgdGFyZ2V0LmhlYWx0aCA+IDApIHtcclxuICAgICAgY29uc3QgcHJvamVjdGlsZURhbWFnZSA9IHByb2plY3RpbGUuZGFtYWdlIHx8IDEwIC8vIFJlZHVjZWQgZGVmYXVsdCBmcm9tIDI1IHRvIDEwXHJcbiAgICAgIHRhcmdldC5oZWFsdGggPSBNYXRoLm1heCgwLCB0YXJnZXQuaGVhbHRoIC0gcHJvamVjdGlsZURhbWFnZSlcclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGZvciBjcml0aWNhbCBoaXQgKGhpZ2ggdmVsb2NpdHkgaW1wYWN0KVxyXG4gICAgICBjb25zdCBpc0NyaXRpY2FsSGl0ID0gcmVsYXRpdmVWZWxvY2l0eSA+IDQwMFxyXG4gICAgICBcclxuICAgICAgaWYgKGlzQ3JpdGljYWxIaXQgJiYgdGFyZ2V0LndlYXBvbklkICYmIHRhcmdldC50eXBlID09PSAncGxheWVyJykge1xyXG4gICAgICAgIC8vIFdlYXBvbiBzd2FwIG9uIGNyaXRpY2FsIGhpdCAtIGRyb3Agd2VhcG9uIGFzIHBpY2t1cFxyXG4gICAgICAgIHNwYXduV2VhcG9uUGlja3VwKHdvcmxkLCB0YXJnZXQucG9zaXRpb24sIHRhcmdldC53ZWFwb25JZClcclxuICAgICAgICB0YXJnZXQud2VhcG9uSWQgPSB1bmRlZmluZWRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBSZW1vdmUgcHJvamVjdGlsZSBvciByZWR1Y2UgcGllcmNpbmdcclxuICAgIGlmIChwcm9qZWN0aWxlLmhpdHNSZW1haW5pbmcgPD0gMSkge1xyXG4gICAgICB3b3JsZC5lbnRpdGllcy5kZWxldGUocHJvamVjdGlsZS5pZClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByb2plY3RpbGUuaGl0c1JlbWFpbmluZy0tXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4vLyBDaGFpbiBrbm9ja2JhY2sgLSB3aGVuIG1vdmluZyBjaXJjbGUgZm9yY2VzIGFub3RoZXIgaW50byBhIHRoaXJkXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseUNoYWluS25vY2tiYWNrKHdvcmxkOiBQaHlzaWNzV29ybGQsIGNvbGxpc2lvbjogQ29sbGlzaW9uKTogdm9pZCB7XHJcbiAgY29uc3QgeyBlbnRpdHlBLCBlbnRpdHlCIH0gPSBjb2xsaXNpb25cclxuICBjb25zdCBwdXNoaW5nRW50aXR5ID0gVmVjdG9yLm1hZ25pdHVkZShlbnRpdHlBLnZlbG9jaXR5KSA+IFZlY3Rvci5tYWduaXR1ZGUoZW50aXR5Qi52ZWxvY2l0eSkgPyBlbnRpdHlBIDogZW50aXR5QlxyXG4gIGNvbnN0IHB1c2hlZEVudGl0eSA9IHB1c2hpbmdFbnRpdHkgPT09IGVudGl0eUEgPyBlbnRpdHlCIDogZW50aXR5QVxyXG4gIFxyXG4gIC8vIEZpbmQgZW50aXRpZXMgdGhhdCBtaWdodCBiZSBoaXQgYnkgdGhlIHB1c2hlZCBlbnRpdHlcclxuICBjb25zdCBjaGFpblJhZGl1cyA9IHB1c2hlZEVudGl0eS5yYWRpdXMgKyA1MCAvLyBEZXRlY3Rpb24gcmFuZ2VcclxuICBcclxuICBmb3IgKGNvbnN0IFtpZCwgZW50aXR5XSBvZiB3b3JsZC5lbnRpdGllcykge1xyXG4gICAgaWYgKGVudGl0eS5pZCA9PT0gcHVzaGVkRW50aXR5LmlkIHx8IGVudGl0eS5pZCA9PT0gcHVzaGluZ0VudGl0eS5pZCkgY29udGludWVcclxuICAgIFxyXG4gICAgY29uc3QgZGlzdGFuY2UgPSBWZWN0b3IuZGlzdGFuY2UocHVzaGVkRW50aXR5LnBvc2l0aW9uLCBlbnRpdHkucG9zaXRpb24pXHJcbiAgICBpZiAoZGlzdGFuY2UgPD0gY2hhaW5SYWRpdXMpIHtcclxuICAgICAgLy8gQXBwbHkgcmVkdWNlZCBrbm9ja2JhY2tcclxuICAgICAgY29uc3Qga25vY2tiYWNrRGlyZWN0aW9uID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3Iuc3VidHJhY3QoZW50aXR5LnBvc2l0aW9uLCBwdXNoZWRFbnRpdHkucG9zaXRpb24pKVxyXG4gICAgICBjb25zdCBrbm9ja2JhY2tGb3JjZSA9IFZlY3Rvci5tYWduaXR1ZGUocHVzaGVkRW50aXR5LnZlbG9jaXR5KSAqIDAuMyAvLyBSZWR1Y2VkIGZvcmNlXHJcbiAgICAgIFxyXG4gICAgICBpZiAoIWVudGl0eS5pc1N0YXRpYykge1xyXG4gICAgICAgIGVudGl0eS52ZWxvY2l0eSA9IFZlY3Rvci5hZGQoZW50aXR5LnZlbG9jaXR5LCBWZWN0b3IubXVsdGlwbHkoa25vY2tiYWNrRGlyZWN0aW9uLCBrbm9ja2JhY2tGb3JjZSkpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHNwYXduV2VhcG9uUGlja3VwKHdvcmxkOiBQaHlzaWNzV29ybGQsIHBvc2l0aW9uOiBWZWN0b3IsIHdlYXBvbklkOiBzdHJpbmcpOiB2b2lkIHtcclxuICBjb25zdCBwaWNrdXAgPSBjcmVhdGVDaXJjbGVFbnRpdHkoXHJcbiAgICBgcGlja3VwXyR7RGF0ZS5ub3coKX1fJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSl9YCxcclxuICAgIHBvc2l0aW9uLngsXHJcbiAgICBwb3NpdGlvbi55LFxyXG4gICAgMTUsXHJcbiAgICAncGlja3VwJ1xyXG4gIClcclxuICBwaWNrdXAud2VhcG9uSWQgPSB3ZWFwb25JZFxyXG4gIHBpY2t1cC5pc1N0YXRpYyA9IHRydWVcclxuICBwaWNrdXAubGlmZXRpbWUgPSAxNTAwMCAvLyAxNSBzZWNvbmRzXHJcbiAgXHJcbiAgd29ybGQuZW50aXRpZXMuc2V0KHBpY2t1cC5pZCwgcGlja3VwKVxyXG59XHJcblxyXG4vLyBBcHBseSBmcmljdGlvbiB0byBhbGwgZW50aXRpZXNcclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5RnJpY3Rpb24od29ybGQ6IFBoeXNpY3NXb3JsZCk6IHZvaWQge1xyXG4gIGZvciAoY29uc3QgW2lkLCBlbnRpdHldIG9mIHdvcmxkLmVudGl0aWVzKSB7XHJcbiAgICBpZiAoIWVudGl0eS5pc1N0YXRpYyAmJiBlbnRpdHkudHlwZSAhPT0gJ3Byb2plY3RpbGUnKSB7XHJcbiAgICAgIGVudGl0eS52ZWxvY2l0eSA9IFZlY3Rvci5tdWx0aXBseShlbnRpdHkudmVsb2NpdHksIGVudGl0eS5mcmljdGlvbilcclxuICAgICAgXHJcbiAgICAgIC8vIFN0b3AgdmVyeSBzbG93IG1vdmVtZW50IHRvIHByZXZlbnQgaml0dGVyXHJcbiAgICAgIGlmIChWZWN0b3IubWFnbml0dWRlKGVudGl0eS52ZWxvY2l0eSkgPCAwLjEpIHtcclxuICAgICAgICBlbnRpdHkudmVsb2NpdHkgPSBWZWN0b3IuY3JlYXRlKClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gSW50ZWdyYXRlIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eSB1c2luZyBWZXJsZXQgaW50ZWdyYXRpb25cclxuZXhwb3J0IGZ1bmN0aW9uIGludGVncmF0ZShlbnRpdHk6IENpcmNsZUVudGl0eSwgZHQ6IG51bWJlcik6IHZvaWQge1xyXG4gIGlmIChlbnRpdHkuaXNTdGF0aWMpIHJldHVyblxyXG4gIFxyXG4gIC8vIEFwcGx5IGdyYXZpdHlcclxuICBlbnRpdHkudmVsb2NpdHkgPSBWZWN0b3IuYWRkKGVudGl0eS52ZWxvY2l0eSwgVmVjdG9yLm11bHRpcGx5KGVudGl0eS5hY2NlbGVyYXRpb24sIGR0KSlcclxuICBcclxuICAvLyBVcGRhdGUgcG9zaXRpb25cclxuICBlbnRpdHkucG9zaXRpb24gPSBWZWN0b3IuYWRkKGVudGl0eS5wb3NpdGlvbiwgVmVjdG9yLm11bHRpcGx5KGVudGl0eS52ZWxvY2l0eSwgZHQpKVxyXG4gIFxyXG4gIC8vIFJlc2V0IGFjY2VsZXJhdGlvbiBmb3IgbmV4dCBmcmFtZVxyXG4gIGVudGl0eS5hY2NlbGVyYXRpb24gPSBWZWN0b3IuY3JlYXRlKClcclxufVxyXG5cclxuLy8gQm91bmRhcnkgY29sbGlzaW9uXHJcbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVCb3VuZGFyeUNvbGxpc2lvbihlbnRpdHk6IENpcmNsZUVudGl0eSwgYm91bmRzOiB7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0pOiB2b2lkIHtcclxuICBpZiAoZW50aXR5LmlzU3RhdGljKSByZXR1cm5cclxuICBcclxuICAvLyBQcm9qZWN0aWxlcyBzaG91bGQgZGlzYXBwZWFyIHdoZW4gaGl0dGluZyB3YWxscyAobW9yZSByZWFsaXN0aWMpXHJcbiAgaWYgKGVudGl0eS50eXBlID09PSAncHJvamVjdGlsZScpIHtcclxuICAgIGlmIChlbnRpdHkucG9zaXRpb24ueCAtIGVudGl0eS5yYWRpdXMgPD0gMCB8fCBcclxuICAgICAgICBlbnRpdHkucG9zaXRpb24ueCArIGVudGl0eS5yYWRpdXMgPj0gYm91bmRzLndpZHRoIHx8XHJcbiAgICAgICAgZW50aXR5LnBvc2l0aW9uLnkgLSBlbnRpdHkucmFkaXVzIDw9IDAgfHwgXHJcbiAgICAgICAgZW50aXR5LnBvc2l0aW9uLnkgKyBlbnRpdHkucmFkaXVzID49IGJvdW5kcy5oZWlnaHQpIHtcclxuICAgICAgLy8gTWFyayBmb3IgcmVtb3ZhbCBieSBzZXR0aW5nIGhlYWx0aCB0byAwXHJcbiAgICAgIGVudGl0eS5oZWFsdGggPSAwXHJcbiAgICAgIHJldHVyblxyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICBjb25zdCBib3VuY2VGYWN0b3IgPSBlbnRpdHkucmVzdGl0dXRpb24gKiAwLjk1IC8vIFNsaWdodCBlbmVyZ3kgbG9zcyBmb3IgcmVhbGlzdGljIGJvdW5jaW5nXHJcbiAgXHJcbiAgLy8gTGVmdCBib3VuZGFyeVxyXG4gIGlmIChlbnRpdHkucG9zaXRpb24ueCAtIGVudGl0eS5yYWRpdXMgPCAwKSB7XHJcbiAgICBlbnRpdHkucG9zaXRpb24ueCA9IGVudGl0eS5yYWRpdXNcclxuICAgIGVudGl0eS52ZWxvY2l0eS54ID0gLWVudGl0eS52ZWxvY2l0eS54ICogYm91bmNlRmFjdG9yXHJcbiAgICAvLyBTbWFsbCByYW5kb20gY29tcG9uZW50IGZvciB2YXJpZXR5XHJcbiAgICBlbnRpdHkudmVsb2NpdHkueSArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMFxyXG4gIH1cclxuICBcclxuICAvLyBSaWdodCBib3VuZGFyeVxyXG4gIGlmIChlbnRpdHkucG9zaXRpb24ueCArIGVudGl0eS5yYWRpdXMgPiBib3VuZHMud2lkdGgpIHtcclxuICAgIGVudGl0eS5wb3NpdGlvbi54ID0gYm91bmRzLndpZHRoIC0gZW50aXR5LnJhZGl1c1xyXG4gICAgZW50aXR5LnZlbG9jaXR5LnggPSAtZW50aXR5LnZlbG9jaXR5LnggKiBib3VuY2VGYWN0b3JcclxuICAgIC8vIFNtYWxsIHJhbmRvbSBjb21wb25lbnQgZm9yIHZhcmlldHlcclxuICAgIGVudGl0eS52ZWxvY2l0eS55ICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwXHJcbiAgfVxyXG4gIFxyXG4gIC8vIFRvcCBib3VuZGFyeVxyXG4gIGlmIChlbnRpdHkucG9zaXRpb24ueSAtIGVudGl0eS5yYWRpdXMgPCAwKSB7XHJcbiAgICBlbnRpdHkucG9zaXRpb24ueSA9IGVudGl0eS5yYWRpdXNcclxuICAgIGVudGl0eS52ZWxvY2l0eS55ID0gLWVudGl0eS52ZWxvY2l0eS55ICogYm91bmNlRmFjdG9yXHJcbiAgICAvLyBTbWFsbCByYW5kb20gY29tcG9uZW50IGZvciB2YXJpZXR5XHJcbiAgICBlbnRpdHkudmVsb2NpdHkueCArPSAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAyMFxyXG4gIH1cclxuICBcclxuICAvLyBCb3R0b20gYm91bmRhcnlcclxuICBpZiAoZW50aXR5LnBvc2l0aW9uLnkgKyBlbnRpdHkucmFkaXVzID4gYm91bmRzLmhlaWdodCkge1xyXG4gICAgZW50aXR5LnBvc2l0aW9uLnkgPSBib3VuZHMuaGVpZ2h0IC0gZW50aXR5LnJhZGl1c1xyXG4gICAgZW50aXR5LnZlbG9jaXR5LnkgPSAtZW50aXR5LnZlbG9jaXR5LnkgKiBib3VuY2VGYWN0b3JcclxuICAgIC8vIFNtYWxsIHJhbmRvbSBjb21wb25lbnQgZm9yIHZhcmlldHlcclxuICAgIGVudGl0eS52ZWxvY2l0eS54ICs9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDIwXHJcbiAgfVxyXG59XHJcblxyXG4vLyBNYWluIHBoeXNpY3Mgc2ltdWxhdGlvbiBzdGVwXHJcbmV4cG9ydCBmdW5jdGlvbiBzaW11bGF0ZVN0ZXAod29ybGQ6IFBoeXNpY3NXb3JsZCwgZGVsdGFUaW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICB3b3JsZC50aW1lQWNjdW11bGF0b3IgKz0gZGVsdGFUaW1lXHJcbiAgXHJcbiAgLy8gRml4ZWQgdGltZXN0ZXAgd2l0aCBhY2N1bXVsYXRvciBwYXR0ZXJuIGZvciBkZXRlcm1pbmlzbVxyXG4gIHdoaWxlICh3b3JsZC50aW1lQWNjdW11bGF0b3IgPj0gd29ybGQuZml4ZWRUaW1lU3RlcCkge1xyXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpXHJcbiAgICBcclxuICAgIC8vIFJlbW92ZSBleHBpcmVkIGVudGl0aWVzXHJcbiAgICBmb3IgKGNvbnN0IFtpZCwgZW50aXR5XSBvZiB3b3JsZC5lbnRpdGllcykge1xyXG4gICAgICBpZiAoZW50aXR5LmxpZmV0aW1lICYmIGN1cnJlbnRUaW1lID4gKGVudGl0eS5saWZldGltZSArIChlbnRpdHkgYXMgYW55KS5zcGF3blRpbWUgfHwgMCkpIHtcclxuICAgICAgICB3b3JsZC5lbnRpdGllcy5kZWxldGUoaWQpXHJcbiAgICAgICAgY29udGludWVcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gUmVtb3ZlIGRlYWQgZW50aXRpZXNcclxuICAgICAgaWYgKGVudGl0eS5oZWFsdGggPD0gMCkge1xyXG4gICAgICAgIHdvcmxkLmVudGl0aWVzLmRlbGV0ZShpZClcclxuICAgICAgICBjb250aW51ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSB3ZWFwb24gc3lzdGVtcyBhbmQgZW5lcmd5XHJcbiAgICBmb3IgKGNvbnN0IFtpZCwgZW50aXR5XSBvZiB3b3JsZC5lbnRpdGllcykge1xyXG4gICAgICB1cGRhdGVXZWFwb25Db29sZG93bnMoZW50aXR5LCBjdXJyZW50VGltZSlcclxuICAgICAgcmVnZW5lcmF0ZUVuZXJneShlbnRpdHksIHdvcmxkLmZpeGVkVGltZVN0ZXApXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFVwZGF0ZSBBSSAod2lsbCBiZSBjYWxsZWQgd2l0aCB3ZWFwb25zIGZyb20gb3V0c2lkZSlcclxuICAgIGlmICgod29ybGQgYXMgYW55KS53ZWFwb25zKSB7XHJcbiAgICAgIGZvciAoY29uc3QgW2lkLCBlbnRpdHldIG9mIHdvcmxkLmVudGl0aWVzKSB7XHJcbiAgICAgICAgaWYgKGVudGl0eS5oZWFsdGggPiAwKSB7XHJcbiAgICAgICAgICB1cGRhdGVBSShlbnRpdHksIHdvcmxkLCB3b3JsZC5maXhlZFRpbWVTdGVwLCAod29ybGQgYXMgYW55KS53ZWFwb25zKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBJbnRlZ3JhdGlvbiBzdGVwIC0gaGFuZGxlIHByb2plY3RpbGVzIHNlcGFyYXRlbHlcclxuICAgIGZvciAoY29uc3QgW2lkLCBlbnRpdHldIG9mIHdvcmxkLmVudGl0aWVzKSB7XHJcbiAgICAgIGlmIChlbnRpdHkudHlwZSA9PT0gJ3Byb2plY3RpbGUnKSB7XHJcbiAgICAgICAgLy8gUHJvamVjdGlsZXMgb25seSB1cGRhdGUgcG9zaXRpb24sIG5vIHBoeXNpY3MgaW50ZXJhY3Rpb25zXHJcbiAgICAgICAgZW50aXR5LnBvc2l0aW9uLnggKz0gZW50aXR5LnZlbG9jaXR5LnggKiB3b3JsZC5maXhlZFRpbWVTdGVwXHJcbiAgICAgICAgZW50aXR5LnBvc2l0aW9uLnkgKz0gZW50aXR5LnZlbG9jaXR5LnkgKiB3b3JsZC5maXhlZFRpbWVTdGVwXHJcbiAgICAgICAgLy8gQ2hlY2sgYm91bmRhcmllcyBmb3IgcHJvamVjdGlsZXMgKHJlbW92ZSB3aGVuIGhpdHRpbmcgd2FsbHMpXHJcbiAgICAgICAgaWYgKGVudGl0eS5wb3NpdGlvbi54IC0gZW50aXR5LnJhZGl1cyA8PSAwIHx8IFxyXG4gICAgICAgICAgICBlbnRpdHkucG9zaXRpb24ueCArIGVudGl0eS5yYWRpdXMgPj0gd29ybGQuYm91bmRzLndpZHRoIHx8XHJcbiAgICAgICAgICAgIGVudGl0eS5wb3NpdGlvbi55IC0gZW50aXR5LnJhZGl1cyA8PSAwIHx8IFxyXG4gICAgICAgICAgICBlbnRpdHkucG9zaXRpb24ueSArIGVudGl0eS5yYWRpdXMgPj0gd29ybGQuYm91bmRzLmhlaWdodCkge1xyXG4gICAgICAgICAgZW50aXR5LmhlYWx0aCA9IDAgLy8gTWFyayBmb3IgcmVtb3ZhbFxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBOb3JtYWwgcGh5c2ljcyBmb3Igbm9uLXByb2plY3RpbGVzXHJcbiAgICAgICAgaW50ZWdyYXRlKGVudGl0eSwgd29ybGQuZml4ZWRUaW1lU3RlcClcclxuICAgICAgICBoYW5kbGVCb3VuZGFyeUNvbGxpc2lvbihlbnRpdHksIHdvcmxkLmJvdW5kcylcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBDb2xsaXNpb24gZGV0ZWN0aW9uIGFuZCByZXNwb25zZVxyXG4gICAgY29uc3QgZW50aXRpZXMgPSBBcnJheS5mcm9tKHdvcmxkLmVudGl0aWVzLnZhbHVlcygpKVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRpdGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBlbnRpdGllcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpc2lvbiA9IGRldGVjdENvbGxpc2lvbihlbnRpdGllc1tpXSwgZW50aXRpZXNbal0pXHJcbiAgICAgICAgaWYgKGNvbGxpc2lvbikge1xyXG4gICAgICAgICAgcmVzb2x2ZUNvbGxpc2lvbihjb2xsaXNpb24sIHdvcmxkKVxyXG4gICAgICAgICAgYXBwbHlDaGFpbktub2NrYmFjayh3b3JsZCwgY29sbGlzaW9uKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBcHBseSBmcmljdGlvblxyXG4gICAgYXBwbHlGcmljdGlvbih3b3JsZClcclxuICAgIFxyXG4gICAgd29ybGQudGltZUFjY3VtdWxhdG9yIC09IHdvcmxkLmZpeGVkVGltZVN0ZXBcclxuICB9XHJcbn1cclxuXHJcbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGZvciBleHRlcm5hbCB1c2VcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZEZvcmNlKGVudGl0eTogQ2lyY2xlRW50aXR5LCBmb3JjZTogVmVjdG9yKTogdm9pZCB7XHJcbiAgaWYgKCFlbnRpdHkuaXNTdGF0aWMpIHtcclxuICAgIGVudGl0eS5hY2NlbGVyYXRpb24gPSBWZWN0b3IuYWRkKGVudGl0eS5hY2NlbGVyYXRpb24sIFZlY3Rvci5tdWx0aXBseShmb3JjZSwgMSAvIGVudGl0eS5tYXNzKSlcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRWZWxvY2l0eShlbnRpdHk6IENpcmNsZUVudGl0eSwgdmVsb2NpdHk6IFZlY3Rvcik6IHZvaWQge1xyXG4gIGlmICghZW50aXR5LmlzU3RhdGljKSB7XHJcbiAgICBlbnRpdHkudmVsb2NpdHkgPSB2ZWxvY2l0eVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRlbGVwb3J0KGVudGl0eTogQ2lyY2xlRW50aXR5LCBwb3NpdGlvbjogVmVjdG9yKTogdm9pZCB7XHJcbiAgZW50aXR5LnBvc2l0aW9uID0gcG9zaXRpb25cclxufVxyXG5cclxuLy8gV2VhcG9uIHN5c3RlbSBpbnRlZ3JhdGlvblxyXG5leHBvcnQgZnVuY3Rpb24gZmlyZVdlYXBvbih3b3JsZDogUGh5c2ljc1dvcmxkLCBlbnRpdHlJZDogc3RyaW5nLCB3ZWFwb25EYXRhOiBhbnksIHRhcmdldERpcmVjdGlvbjogVmVjdG9yLCBjdXJyZW50VGltZTogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgY29uc3QgZW50aXR5ID0gd29ybGQuZW50aXRpZXMuZ2V0KGVudGl0eUlkKVxyXG4gIGlmICghZW50aXR5KSByZXR1cm4gZmFsc2VcclxuICBcclxuICAvLyBDaGVjayBjb29sZG93biBhbmQgZW5lcmd5XHJcbiAgY29uc3QgY29vbGRvd25FbmQgPSBlbnRpdHkud2VhcG9uQ29vbGRvd25zPy5nZXQod2VhcG9uRGF0YS5pZCkgfHwgMFxyXG4gIGlmIChjdXJyZW50VGltZSA8IGNvb2xkb3duRW5kKSByZXR1cm4gZmFsc2VcclxuICBpZiAoKGVudGl0eS5lbmVyZ3kgfHwgMCkgPCB3ZWFwb25EYXRhLmNvc3QpIHJldHVybiBmYWxzZVxyXG4gIFxyXG4gIC8vIFVwZGF0ZSBlbnRpdHkgY29vbGRvd24gYW5kIGVuZXJneVxyXG4gIGlmICghZW50aXR5LndlYXBvbkNvb2xkb3ducykgZW50aXR5LndlYXBvbkNvb2xkb3ducyA9IG5ldyBNYXAoKVxyXG4gIGVudGl0eS53ZWFwb25Db29sZG93bnMuc2V0KHdlYXBvbkRhdGEuaWQsIGN1cnJlbnRUaW1lICsgd2VhcG9uRGF0YS5jb29sZG93bk1zKVxyXG4gIGVudGl0eS5lbmVyZ3kgPSAoZW50aXR5LmVuZXJneSB8fCAwKSAtIHdlYXBvbkRhdGEuY29zdFxyXG4gIFxyXG4gIC8vIENyZWF0ZSB3ZWFwb24gZWZmZWN0XHJcbiAgaWYgKHdlYXBvbkRhdGEudHlwZSA9PT0gJ3Byb2plY3RpbGUnKSB7XHJcbiAgICBjb25zdCBwcm9qZWN0aWxlID0gY3JlYXRlV2VhcG9uUHJvamVjdGlsZShlbnRpdHksIHdlYXBvbkRhdGEsIHRhcmdldERpcmVjdGlvbiwgY3VycmVudFRpbWUpXHJcbiAgICB3b3JsZC5lbnRpdGllcy5zZXQocHJvamVjdGlsZS5pZCwgcHJvamVjdGlsZSlcclxuICB9IGVsc2UgaWYgKHdlYXBvbkRhdGEudHlwZSA9PT0gJ2F1cmEnKSB7XHJcbiAgICBjb25zdCBhdXJhID0gY3JlYXRlV2VhcG9uQXVyYShlbnRpdHksIHdlYXBvbkRhdGEsIGN1cnJlbnRUaW1lKVxyXG4gICAgd29ybGQuZW50aXRpZXMuc2V0KGF1cmEuaWQsIGF1cmEpXHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiB0cnVlXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZVdlYXBvblByb2plY3RpbGUob3duZXI6IENpcmNsZUVudGl0eSwgd2VhcG9uRGF0YTogYW55LCBkaXJlY3Rpb246IFZlY3RvciwgY3VycmVudFRpbWU6IG51bWJlcik6IFdlYXBvblByb2plY3RpbGUge1xyXG4gIGNvbnN0IG5vcm1hbGl6ZWREaXIgPSBWZWN0b3Iubm9ybWFsaXplKGRpcmVjdGlvbilcclxuICBjb25zdCBzcGF3bk9mZnNldCA9IFZlY3Rvci5tdWx0aXBseShub3JtYWxpemVkRGlyLCBvd25lci5yYWRpdXMgKyB3ZWFwb25EYXRhLnJhZGl1cyArIDIpXHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGlkOiBgcHJvamVjdGlsZV8ke2N1cnJlbnRUaW1lfV8ke01hdGgucmFuZG9tKCl9YCxcclxuICAgIHR5cGU6ICdwcm9qZWN0aWxlJyxcclxuICAgIHdlYXBvbklkOiB3ZWFwb25EYXRhLmlkLFxyXG4gICAgb3duZXJJZDogb3duZXIuaWQsXHJcbiAgICBwb3NpdGlvbjogVmVjdG9yLmFkZChvd25lci5wb3NpdGlvbiwgc3Bhd25PZmZzZXQpLFxyXG4gICAgdmVsb2NpdHk6IFZlY3Rvci5tdWx0aXBseShub3JtYWxpemVkRGlyLCB3ZWFwb25EYXRhLnByb2plY3RpbGVTcGVlZCB8fCAyMDApLFxyXG4gICAgYWNjZWxlcmF0aW9uOiB7IHg6IDAsIHk6IDAgfSxcclxuICAgIHJhZGl1czogd2VhcG9uRGF0YS5yYWRpdXMsXHJcbiAgICBtYXNzOiAxLFxyXG4gICAgaGVhbHRoOiAxLFxyXG4gICAgbWF4SGVhbHRoOiAxLFxyXG4gICAgZGFtYWdlOiB3ZWFwb25EYXRhLmJhc2VEYW1hZ2UsXHJcbiAgICByZXN0aXR1dGlvbjogMC44LFxyXG4gICAgZnJpY3Rpb246IDAuMDIsXHJcbiAgICBpc1N0YXRpYzogZmFsc2UsXHJcbiAgICBzcGVlZDogd2VhcG9uRGF0YS5wcm9qZWN0aWxlU3BlZWQgfHwgMjAwLFxyXG4gICAgbGlmZXRpbWU6IHdlYXBvbkRhdGEubGlmZXRpbWUgfHwgMjAwMCxcclxuICAgIHBpZXJjaW5nOiB3ZWFwb25EYXRhLnBpZXJjaW5nIHx8IDAsXHJcbiAgICBoaXRzUmVtYWluaW5nOiB3ZWFwb25EYXRhLnBpZXJjaW5nIHx8IDAsXHJcbiAgICBib3VuY2VzOiB3ZWFwb25EYXRhLmJvdW5jZXMgfHwgMCxcclxuICAgIGJvdW5jZXNSZW1haW5pbmc6IHdlYXBvbkRhdGEuYm91bmNlcyB8fCAwLFxyXG4gICAgc3BlY2lhbDogd2VhcG9uRGF0YS5zcGVjaWFsIHx8IFtdLFxyXG4gICAgc3Bhd25UaW1lOiBjdXJyZW50VGltZVxyXG4gIH0gYXMgV2VhcG9uUHJvamVjdGlsZSAmIHsgc3Bhd25UaW1lOiBudW1iZXIgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBjcmVhdGVXZWFwb25BdXJhKG93bmVyOiBDaXJjbGVFbnRpdHksIHdlYXBvbkRhdGE6IGFueSwgY3VycmVudFRpbWU6IG51bWJlcik6IFdlYXBvbkF1cmEge1xyXG4gIHJldHVybiB7XHJcbiAgICBpZDogYGF1cmFfJHtjdXJyZW50VGltZX1fJHtNYXRoLnJhbmRvbSgpfWAsXHJcbiAgICB0eXBlOiAnYXVyYScsXHJcbiAgICB3ZWFwb25JZDogd2VhcG9uRGF0YS5pZCxcclxuICAgIG93bmVySWQ6IG93bmVyLmlkLFxyXG4gICAgcG9zaXRpb246IHsgLi4ub3duZXIucG9zaXRpb24gfSxcclxuICAgIHZlbG9jaXR5OiB7IHg6IDAsIHk6IDAgfSxcclxuICAgIGFjY2VsZXJhdGlvbjogeyB4OiAwLCB5OiAwIH0sXHJcbiAgICByYWRpdXM6IHdlYXBvbkRhdGEuYXVyYVJhZGl1cyB8fCB3ZWFwb25EYXRhLnJhZGl1cyxcclxuICAgIG1hc3M6IDAsXHJcbiAgICBoZWFsdGg6IDEsXHJcbiAgICBtYXhIZWFsdGg6IDEsXHJcbiAgICBkYW1hZ2U6IHdlYXBvbkRhdGEuYmFzZURhbWFnZSxcclxuICAgIHJlc3RpdHV0aW9uOiAwLFxyXG4gICAgZnJpY3Rpb246IDAsXHJcbiAgICBpc1N0YXRpYzogdHJ1ZSxcclxuICAgIGR1cmF0aW9uOiB3ZWFwb25EYXRhLmF1cmFEdXJhdGlvbiB8fCAxMDAwLFxyXG4gICAgc3BlY2lhbDogd2VhcG9uRGF0YS5zcGVjaWFsIHx8IFtdLFxyXG4gICAgYWZmZWN0ZWRFbnRpdGllczogbmV3IFNldCgpLFxyXG4gICAgbGlmZXRpbWU6IHdlYXBvbkRhdGEuYXVyYUR1cmF0aW9uIHx8IDEwMDAsXHJcbiAgICBzcGF3blRpbWU6IGN1cnJlbnRUaW1lXHJcbiAgfSBhcyBXZWFwb25BdXJhICYgeyBzcGF3blRpbWU6IG51bWJlciB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVXZWFwb25Db29sZG93bnMoZW50aXR5OiBDaXJjbGVFbnRpdHksIGN1cnJlbnRUaW1lOiBudW1iZXIpOiB2b2lkIHtcclxuICBpZiAoIWVudGl0eS53ZWFwb25Db29sZG93bnMpIHJldHVyblxyXG4gIFxyXG4gIGZvciAoY29uc3QgW3dlYXBvbklkLCBjb29sZG93bkVuZF0gb2YgZW50aXR5LndlYXBvbkNvb2xkb3ducykge1xyXG4gICAgaWYgKGN1cnJlbnRUaW1lID49IGNvb2xkb3duRW5kKSB7XHJcbiAgICAgIGVudGl0eS53ZWFwb25Db29sZG93bnMuZGVsZXRlKHdlYXBvbklkKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2VuZXJhdGVFbmVyZ3koZW50aXR5OiBDaXJjbGVFbnRpdHksIGR0OiBudW1iZXIpOiB2b2lkIHtcclxuICBpZiAoZW50aXR5LmVuZXJneSAhPT0gdW5kZWZpbmVkICYmIGVudGl0eS5tYXhFbmVyZ3kgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgZW50aXR5LmVuZXJneSA9IE1hdGgubWluKGVudGl0eS5tYXhFbmVyZ3ksIGVudGl0eS5lbmVyZ3kgKyAyMCAqIGR0KSAvLyAyMCBlbmVyZ3kvc2VjXHJcbiAgfVxyXG59XHJcblxyXG4vLyBBSSBDb21iYXQgU3lzdGVtXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVBSShlbnRpdHk6IENpcmNsZUVudGl0eSwgd29ybGQ6IFBoeXNpY3NXb3JsZCwgZGVsdGFUaW1lOiBudW1iZXIsIHdlYXBvbnM6IGFueVtdKTogdm9pZCB7XHJcbiAgaWYgKCFlbnRpdHkuaWQuaW5jbHVkZXMoJ2FpJykgJiYgIWVudGl0eS5pZC5pbmNsdWRlcygnYm90JykpIHJldHVyblxyXG4gIFxyXG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKVxyXG4gIFxyXG4gIC8vIEZpbmQgbmVhcmVzdCBlbmVteVxyXG4gIGxldCBuZWFyZXN0RW5lbXk6IENpcmNsZUVudGl0eSB8IG51bGwgPSBudWxsXHJcbiAgbGV0IG5lYXJlc3REaXN0YW5jZSA9IEluZmluaXR5XHJcbiAgXHJcbiAgZm9yIChjb25zdCBbaWQsIG90aGVyRW50aXR5XSBvZiB3b3JsZC5lbnRpdGllcykge1xyXG4gICAgaWYgKG90aGVyRW50aXR5ID09PSBlbnRpdHkgfHwgb3RoZXJFbnRpdHkuaGVhbHRoIDw9IDApIGNvbnRpbnVlXHJcbiAgICBpZiAoZW50aXR5LmlkLmluY2x1ZGVzKCdib3QnKSAmJiBvdGhlckVudGl0eS5pZC5pbmNsdWRlcygnYm90JykpIGNvbnRpbnVlIC8vIEJvdHMgZG9uJ3QgZmlnaHQgZWFjaCBvdGhlclxyXG4gICAgXHJcbiAgICBjb25zdCBkaXN0YW5jZSA9IFZlY3Rvci5kaXN0YW5jZShlbnRpdHkucG9zaXRpb24sIG90aGVyRW50aXR5LnBvc2l0aW9uKVxyXG4gICAgaWYgKGRpc3RhbmNlIDwgbmVhcmVzdERpc3RhbmNlKSB7XHJcbiAgICAgIG5lYXJlc3REaXN0YW5jZSA9IGRpc3RhbmNlXHJcbiAgICAgIG5lYXJlc3RFbmVteSA9IG90aGVyRW50aXR5XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIGlmICghbmVhcmVzdEVuZW15KSByZXR1cm5cclxuICBcclxuICAvLyBBSSBCZWhhdmlvciBiYXNlZCBvbiBkaXN0YW5jZSBhbmQgaGVhbHRoXHJcbiAgY29uc3QgaGVhbHRoUmF0aW8gPSBlbnRpdHkuaGVhbHRoIC8gZW50aXR5Lm1heEhlYWx0aFxyXG4gIGNvbnN0IGRpc3RhbmNlVG9FbmVteSA9IG5lYXJlc3REaXN0YW5jZVxyXG4gIFxyXG4gIC8vIE1vdmVtZW50IEFJXHJcbiAgaWYgKGRpc3RhbmNlVG9FbmVteSA+IDEwMCkge1xyXG4gICAgLy8gTW92ZSB0b3dhcmRzIGVuZW15XHJcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5zdWJ0cmFjdChuZWFyZXN0RW5lbXkucG9zaXRpb24sIGVudGl0eS5wb3NpdGlvbikpXHJcbiAgICBjb25zdCBtb3ZlRm9yY2UgPSBWZWN0b3IubXVsdGlwbHkoZGlyZWN0aW9uLCAyMDAgKiBoZWFsdGhSYXRpbykgLy8gU2xvd2VyIHdoZW4gaHVydFxyXG4gICAgYWRkRm9yY2UoZW50aXR5LCBtb3ZlRm9yY2UpXHJcbiAgfSBlbHNlIGlmIChkaXN0YW5jZVRvRW5lbXkgPCA1MCAmJiBoZWFsdGhSYXRpbyA8IDAuMykge1xyXG4gICAgLy8gUmV0cmVhdCB3aGVuIGxvdyBvbiBoZWFsdGggYW5kIHRvbyBjbG9zZVxyXG4gICAgY29uc3QgZGlyZWN0aW9uID0gVmVjdG9yLm5vcm1hbGl6ZShWZWN0b3Iuc3VidHJhY3QoZW50aXR5LnBvc2l0aW9uLCBuZWFyZXN0RW5lbXkucG9zaXRpb24pKVxyXG4gICAgY29uc3QgcmV0cmVhdEZvcmNlID0gVmVjdG9yLm11bHRpcGx5KGRpcmVjdGlvbiwgMzAwKVxyXG4gICAgYWRkRm9yY2UoZW50aXR5LCByZXRyZWF0Rm9yY2UpXHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIENpcmNsZSBhcm91bmQgZW5lbXlcclxuICAgIGNvbnN0IHRvRW5lbXkgPSBWZWN0b3Iuc3VidHJhY3QobmVhcmVzdEVuZW15LnBvc2l0aW9uLCBlbnRpdHkucG9zaXRpb24pXHJcbiAgICBjb25zdCBwZXJwZW5kaWN1bGFyID0geyB4OiAtdG9FbmVteS55LCB5OiB0b0VuZW15LnggfVxyXG4gICAgY29uc3QgY2lyY2xlRGlyZWN0aW9uID0gVmVjdG9yLm5vcm1hbGl6ZShwZXJwZW5kaWN1bGFyKVxyXG4gICAgY29uc3QgY2lyY2xlRm9yY2UgPSBWZWN0b3IubXVsdGlwbHkoY2lyY2xlRGlyZWN0aW9uLCAxNTApXHJcbiAgICBhZGRGb3JjZShlbnRpdHksIGNpcmNsZUZvcmNlKVxyXG4gIH1cclxuICBcclxuICAvLyBDb21iYXQgQUkgLSB0cnkgdG8gYXR0YWNrIGV2ZXJ5IDEtMiBzZWNvbmRzXHJcbiAgaWYgKCFlbnRpdHkubGFzdEF0dGFja1RpbWUpIGVudGl0eS5sYXN0QXR0YWNrVGltZSA9IDBcclxuICBjb25zdCB0aW1lU2luY2VBdHRhY2sgPSBjdXJyZW50VGltZSAtIGVudGl0eS5sYXN0QXR0YWNrVGltZVxyXG4gIGNvbnN0IGF0dGFja0Nvb2xkb3duID0gMTAwMCArIE1hdGgucmFuZG9tKCkgKiAxMDAwIC8vIDEtMiBzZWNvbmRzXHJcbiAgXHJcbiAgaWYgKHRpbWVTaW5jZUF0dGFjayA+IGF0dGFja0Nvb2xkb3duICYmIGRpc3RhbmNlVG9FbmVteSA8IDIwMCkge1xyXG4gICAgLy8gRmluZCB3ZWFwb24gdG8gdXNlXHJcbiAgICBjb25zdCBhdmFpbGFibGVXZWFwb24gPSB3ZWFwb25zLmZpbmQodyA9PiB3LmlkID09PSBlbnRpdHkud2VhcG9uSWQpXHJcbiAgICBpZiAoYXZhaWxhYmxlV2VhcG9uICYmIGVudGl0eS5lbmVyZ3kgJiYgZW50aXR5LmVuZXJneSA+PSBhdmFpbGFibGVXZWFwb24uY29zdCkge1xyXG4gICAgICBjb25zdCBhdHRhY2tEaXJlY3Rpb24gPSBWZWN0b3Iubm9ybWFsaXplKFZlY3Rvci5zdWJ0cmFjdChuZWFyZXN0RW5lbXkucG9zaXRpb24sIGVudGl0eS5wb3NpdGlvbikpXHJcbiAgICAgIFxyXG4gICAgICAvLyBBZGQgc29tZSBpbmFjY3VyYWN5IHRvIG1ha2UgZmlnaHRzIG1vcmUgaW50ZXJlc3RpbmdcclxuICAgICAgY29uc3QgaW5hY2N1cmFjeSA9IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDAuM1xyXG4gICAgICBjb25zdCBmaW5hbERpcmVjdGlvbiA9IHtcclxuICAgICAgICB4OiBhdHRhY2tEaXJlY3Rpb24ueCArIGluYWNjdXJhY3ksXHJcbiAgICAgICAgeTogYXR0YWNrRGlyZWN0aW9uLnkgKyBpbmFjY3VyYWN5XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmIChmaXJlV2VhcG9uKHdvcmxkLCBlbnRpdHkuaWQsIGF2YWlsYWJsZVdlYXBvbiwgVmVjdG9yLm5vcm1hbGl6ZShmaW5hbERpcmVjdGlvbiksIGN1cnJlbnRUaW1lKSkge1xyXG4gICAgICAgIGVudGl0eS5sYXN0QXR0YWNrVGltZSA9IGN1cnJlbnRUaW1lXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbIlZlY3RvciIsImNyZWF0ZSIsIngiLCJ5IiwiYWRkIiwiYSIsImIiLCJzdWJ0cmFjdCIsIm11bHRpcGx5IiwidiIsInNjYWxhciIsImRvdCIsIm1hZ25pdHVkZSIsIk1hdGgiLCJzcXJ0Iiwibm9ybWFsaXplIiwibWFnIiwiZGlzdGFuY2UiLCJkaWZmIiwibGVycCIsInQiLCJyb3RhdGUiLCJhbmdsZSIsImNvcyIsInNpbiIsImNyZWF0ZVBoeXNpY3NXb3JsZCIsIndpZHRoIiwiaGVpZ2h0IiwiZW50aXRpZXMiLCJNYXAiLCJncmF2aXR5IiwiYWlyRnJpY3Rpb24iLCJ0aW1lQWNjdW11bGF0b3IiLCJmaXhlZFRpbWVTdGVwIiwiYm91bmRzIiwiY3JlYXRlQ2lyY2xlRW50aXR5IiwiaWQiLCJyYWRpdXMiLCJ0eXBlIiwicG9zaXRpb24iLCJ2ZWxvY2l0eSIsImFjY2VsZXJhdGlvbiIsIm1hc3MiLCJQSSIsImhlYWx0aCIsIm1heEhlYWx0aCIsImRhbWFnZSIsInJlc3RpdHV0aW9uIiwiZnJpY3Rpb24iLCJpc1N0YXRpYyIsImludnVsbmVyYWJsZVVudGlsIiwiY3JlYXRlUHJvamVjdGlsZSIsImRpcmVjdGlvbiIsInNwZWVkIiwib3duZXJJZCIsImxpZmV0aW1lIiwicGllcmNpbmciLCJoaXRzUmVtYWluaW5nIiwiZGV0ZWN0Q29sbGlzaW9uIiwibWluRGlzdGFuY2UiLCJub3JtYWwiLCJwZW5ldHJhdGlvbiIsInJlbGF0aXZlVmVsb2NpdHkiLCJlbnRpdHlBIiwiZW50aXR5QiIsInJlc29sdmVDb2xsaXNpb24iLCJjb2xsaXNpb24iLCJ3b3JsZCIsImNvcnJlY3Rpb25QZXJjZW50IiwiY29ycmVjdGlvbiIsInRvdGFsTWFzcyIsImJhc2VEYW1hZ2UiLCJtYXgiLCJtb21lbnR1bURhbWFnZSIsIm1pbiIsImN1cnJlbnRUaW1lIiwiRGF0ZSIsIm5vdyIsInJlbGF0aXZlVmVsIiwidmVsQWxvbmdOb3JtYWwiLCJpbXB1bHNlU2NhbGFyIiwiaW1wdWxzZSIsInJhbmRvbUJvb3N0IiwicmFuZG9tIiwicHJvamVjdGlsZSIsInRhcmdldCIsInByb2plY3RpbGVEYW1hZ2UiLCJpc0NyaXRpY2FsSGl0Iiwid2VhcG9uSWQiLCJzcGF3bldlYXBvblBpY2t1cCIsInVuZGVmaW5lZCIsImRlbGV0ZSIsImFwcGx5Q2hhaW5Lbm9ja2JhY2siLCJwdXNoaW5nRW50aXR5IiwicHVzaGVkRW50aXR5IiwiY2hhaW5SYWRpdXMiLCJlbnRpdHkiLCJrbm9ja2JhY2tEaXJlY3Rpb24iLCJrbm9ja2JhY2tGb3JjZSIsInBpY2t1cCIsInRvU3RyaW5nIiwic3Vic3RyIiwic2V0IiwiYXBwbHlGcmljdGlvbiIsImludGVncmF0ZSIsImR0IiwiaGFuZGxlQm91bmRhcnlDb2xsaXNpb24iLCJib3VuY2VGYWN0b3IiLCJzaW11bGF0ZVN0ZXAiLCJkZWx0YVRpbWUiLCJzcGF3blRpbWUiLCJ1cGRhdGVXZWFwb25Db29sZG93bnMiLCJyZWdlbmVyYXRlRW5lcmd5Iiwid2VhcG9ucyIsInVwZGF0ZUFJIiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwiaSIsImxlbmd0aCIsImoiLCJhZGRGb3JjZSIsImZvcmNlIiwic2V0VmVsb2NpdHkiLCJ0ZWxlcG9ydCIsImZpcmVXZWFwb24iLCJlbnRpdHlJZCIsIndlYXBvbkRhdGEiLCJ0YXJnZXREaXJlY3Rpb24iLCJnZXQiLCJjb29sZG93bkVuZCIsIndlYXBvbkNvb2xkb3ducyIsImVuZXJneSIsImNvc3QiLCJjb29sZG93bk1zIiwiY3JlYXRlV2VhcG9uUHJvamVjdGlsZSIsImF1cmEiLCJjcmVhdGVXZWFwb25BdXJhIiwib3duZXIiLCJub3JtYWxpemVkRGlyIiwic3Bhd25PZmZzZXQiLCJwcm9qZWN0aWxlU3BlZWQiLCJib3VuY2VzIiwiYm91bmNlc1JlbWFpbmluZyIsInNwZWNpYWwiLCJhdXJhUmFkaXVzIiwiZHVyYXRpb24iLCJhdXJhRHVyYXRpb24iLCJhZmZlY3RlZEVudGl0aWVzIiwiU2V0IiwibWF4RW5lcmd5IiwiaW5jbHVkZXMiLCJuZWFyZXN0RW5lbXkiLCJuZWFyZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsIm90aGVyRW50aXR5IiwiaGVhbHRoUmF0aW8iLCJkaXN0YW5jZVRvRW5lbXkiLCJtb3ZlRm9yY2UiLCJyZXRyZWF0Rm9yY2UiLCJ0b0VuZW15IiwicGVycGVuZGljdWxhciIsImNpcmNsZURpcmVjdGlvbiIsImNpcmNsZUZvcmNlIiwibGFzdEF0dGFja1RpbWUiLCJ0aW1lU2luY2VBdHRhY2siLCJhdHRhY2tDb29sZG93biIsImF2YWlsYWJsZVdlYXBvbiIsImZpbmQiLCJ3IiwiYXR0YWNrRGlyZWN0aW9uIiwiaW5hY2N1cmFjeSIsImZpbmFsRGlyZWN0aW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/physics.ts\n"));

/***/ })

});